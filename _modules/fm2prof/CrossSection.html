

<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      <link rel="icon" href="../../_static/favicon.ico">
    
    
      
        <title>fm2prof.CrossSection - FM2PROF Manual</title>
      
    
    
      <link rel="stylesheet" href="../../_static/stylesheets/main.42d9060c.min.css">
      
        
        <link rel="stylesheet" href="../../_static/stylesheets/palette.52561aa6.min.css">
        
      
    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
        <link rel="stylesheet" type="text/css" href="../../_static/sphinxcontrib-images/LightBox2/lightbox2/dist/css/lightbox.css" />
        <link rel="stylesheet" type="text/css" href="../../_static/stylesheets/extra.css" />
    <script>__md_scope=new URL("../..",location),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="deltares" data-md-color-primary="indigo" data-md-color-accent="deep-orange">
  
    
    
      <script>var palette=__md_get("__palette");if(palette&&"object"==typeof palette.color)for(var key of Object.keys(palette.color))document.body.setAttribute("data-md-color-"+key,palette.color[key])</script>
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      <div data-md-component="outdated" hidden>
        <aside class="md-banner md-banner--warning">
          
        </aside>
      </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../../index.html" title="FM2PROF Manual" class="md-header__button md-logo" aria-label="FM2PROF Manual" data-md-component="logo">
      <img src="../../_static/logo_deltares.png" alt="logo">
    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            FM2PROF Manual
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              fm2prof.CrossSection
            
          </span>
        </div>
      </div>
    </div>
    
      <form class="md-header__option" data-md-component="palette">
        
          
          
          <input class="md-option" data-md-color-media="(prefers-color-scheme: light)" data-md-color-scheme="deltares" data-md-color-primary="indigo" data-md-color-accent="deep-orange"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_1">
          
            <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_2" hidden>
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 2a7 7 0 0 1 7 7c0 2.38-1.19 4.47-3 5.74V17a1 1 0 0 1-1 1H9a1 1 0 0 1-1-1v-2.26C6.19 13.47 5 11.38 5 9a7 7 0 0 1 7-7M9 21v-1h6v1a1 1 0 0 1-1 1h-4a1 1 0 0 1-1-1m3-17a5 5 0 0 0-5 5c0 2.05 1.23 3.81 3 4.58V16h4v-2.42c1.77-.77 3-2.53 3-4.58a5 5 0 0 0-5-5z"/></svg>
            </label>
          
        
          
          
          <input class="md-option" data-md-color-media="(prefers-color-scheme: dark)" data-md-color-scheme="slate" data-md-color-primary="indigo" data-md-color-accent="yellow"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_2">
          
            <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_1" hidden>
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 2a7 7 0 0 0-7 7c0 2.38 1.19 4.47 3 5.74V17a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1v-2.26c1.81-1.27 3-3.36 3-5.74a7 7 0 0 0-7-7M9 21a1 1 0 0 0 1 1h4a1 1 0 0 0 1-1v-1H9v1z"/></svg>
            </label>
          
        
      </form>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" aria-label="Clear" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/deltares/fm2prof/" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.0.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    Fm2Prof
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../index.html" title="FM2PROF Manual" class="md-nav__button md-logo" aria-label="FM2PROF Manual" data-md-component="logo">
      <img src="../../_static/logo_deltares.png" alt="logo">
    </a>
    FM2PROF Manual
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/deltares/fm2prof/" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.0.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    Fm2Prof
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../chapters/user_manual/installation.html" class="md-nav__link">
        <span class="md-ellipsis">Installation Instructions</span>
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../chapters/user_manual/quickstart.html" class="md-nav__link">
        <span class="md-ellipsis">Quickstart</span>
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../chapters/user_manual/advanced.html" class="md-nav__link">
        <span class="md-ellipsis">Troubleshooting</span>
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../chapters/user_manual/source.html" class="md-nav__link">
        <span class="md-ellipsis">API</span>
      </a>
    </li>
  

    
      
      
      

  
  
  
    
      
    
    <li class="md-nav__item md-nav__item--section md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_5" data-md-state="indeterminate" type="checkbox" id="__nav_5" checked>
      
      
      
        <label class="md-nav__link" for="__nav_5">
          <span class="md-ellipsis">Technical reference manual</span>
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Technical reference manual" data-md-level="1">
        <label class="md-nav__title" for="__nav_5">
          <span class="md-nav__icon md-icon"></span>
          <span class="md-ellipsis">Technical reference manual</span>
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../chapters/technical_manual/conceptual_design.html" class="md-nav__link">
        <span class="md-ellipsis">Conceptual design</span>
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../chapters/technical_manual/numerical_methods.html" class="md-nav__link">
        <span class="md-ellipsis">Numerical methods</span>
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../chapters/technical_manual/settings.html" class="md-nav__link">
        <span class="md-ellipsis">Settings</span>
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../chapters/technical_manual/files.html" class="md-nav__link">
        <span class="md-ellipsis">Files</span>
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../chapters/technical_manual/glossary.html" class="md-nav__link">
        <span class="md-ellipsis">Glossary of terms</span>
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset" role="main">
                
<a href="https://github.com/deltares/fm2prof/blob/main/docs/_modules/fm2prof/CrossSection.rst" title="Edit this page" class="md-content__button md-icon">
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20.71 7.04c.39-.39.39-1.04 0-1.41l-2.34-2.34c-.37-.39-1.02-.39-1.41 0l-1.84 1.83 3.75 3.75M3 17.25V21h3.75L17.81 9.93l-3.75-3.75L3 17.25z"/></svg>
</a>



  <h1>Source code for fm2prof.CrossSection</h1><div class="highlight"><pre>
<span></span><code><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Contains CrossSection class</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">os</span>

<span class="c1"># Imports from standard library</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span><span class="p">,</span> <span class="n">timedelta</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">reduce</span>
<span class="kn">from</span> <span class="nn">logging</span> <span class="kn">import</span> <span class="n">Logger</span>
<span class="kn">from</span> <span class="nn">time</span> <span class="kn">import</span> <span class="n">time</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">Sequence</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">scipy.optimize</span> <span class="k">as</span> <span class="nn">so</span>

<span class="c1"># Imports from dependencies</span>
<span class="kn">from</span> <span class="nn">scipy.integrate</span> <span class="kn">import</span> <span class="n">cumtrapz</span>

<span class="kn">from</span> <span class="nn">fm2prof</span> <span class="kn">import</span> <span class="n">Functions</span> <span class="k">as</span> <span class="n">FE</span>

<span class="c1"># Imports from package</span>
<span class="kn">from</span> <span class="nn">fm2prof.common</span> <span class="kn">import</span> <span class="n">FM2ProfBase</span><span class="p">,</span> <span class="n">FrictionTable</span>
<span class="kn">from</span> <span class="nn">fm2prof.Import</span> <span class="kn">import</span> <span class="n">FmModelData</span>
<span class="kn">from</span> <span class="nn">fm2prof.IniFile</span> <span class="kn">import</span> <span class="n">IniFile</span>
<span class="kn">from</span> <span class="nn">fm2prof.MaskOutputFile</span> <span class="kn">import</span> <span class="n">MaskOutputFile</span>

<span class="kn">from</span> <span class="nn">.lib</span> <span class="kn">import</span> <span class="n">polysimplify</span> <span class="k">as</span> <span class="n">PS</span>

<span class="n">pd</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">mode</span><span class="o">.</span><span class="n">chained_assignment</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># default=&#39;warn&#39;</span>


<span class="k">class</span> <span class="nc">CrossSection</span><span class="p">(</span><span class="n">FM2ProfBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Use this class to derive cross-sections from fm_data (2D model results).</span>
<span class="sd">    See docs how to acquire fm_data and how to prepare a proper 2D model.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__cs_parameter_css_points</span> <span class="o">=</span> <span class="s2">&quot;MaximumPointsInProfile&quot;</span>
    <span class="n">__cs_parameter_transitionheight_sd</span> <span class="o">=</span> <span class="s2">&quot;SDTransitionHeight&quot;</span>
    <span class="n">__cs_parameter_velocity_threshold</span> <span class="o">=</span> <span class="s2">&quot;AbsoluteVelocityThreshold&quot;</span>
    <span class="n">__cs_parameter_relative_threshold</span> <span class="o">=</span> <span class="s2">&quot;RelativeVelocityThreshold&quot;</span>
    <span class="n">__cs_parameter_min_depth_storage</span> <span class="o">=</span> <span class="s2">&quot;MinimumDepthThreshold&quot;</span>
    <span class="n">__cs_parameter_plassen_timesteps</span> <span class="o">=</span> <span class="s2">&quot;LakeTimesteps&quot;</span>
    <span class="n">__cs_parameter_storagemethod_wli</span> <span class="o">=</span> <span class="s2">&quot;ExtrapolateStorage&quot;</span>
    <span class="n">__cs_parameter_bedlevelcriterium</span> <span class="o">=</span> <span class="s2">&quot;BedlevelCriterium&quot;</span>
    <span class="n">__cs_parameter_SDstorage</span> <span class="o">=</span> <span class="s2">&quot;SDCorrection&quot;</span>
    <span class="n">__cs_parameter_Frictionweighing</span> <span class="o">=</span> <span class="s2">&quot;FrictionweighingMethod&quot;</span>
    <span class="n">__cs_parameter_sdoptimisationmethod</span> <span class="o">=</span> <span class="s2">&quot;sdoptimisationmethod&quot;</span>
    <span class="n">__cs_parameter_skip_maps</span> <span class="o">=</span> <span class="s2">&quot;SkipMaps&quot;</span>
    <span class="n">__cs_parameter_floodplain_base_level</span> <span class="o">=</span> <span class="s2">&quot;SDFloodplainBase&quot;</span>
    <span class="n">__cs_parameter_minwidth</span> <span class="o">=</span> <span class="s2">&quot;MinimumTotalWidth&quot;</span>
    <span class="n">__logger</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">length</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">location</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">,</span>
        <span class="n">branchid</span><span class="o">=</span><span class="s2">&quot;not defined&quot;</span><span class="p">,</span>
        <span class="n">chainage</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">fm_data</span><span class="p">:</span> <span class="n">FmModelData</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">logger</span><span class="p">:</span> <span class="n">Logger</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">inifile</span><span class="p">:</span> <span class="n">IniFile</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Arguments:</span>
<span class="sd">            InputParam_dict {Dictionary} -- [description]</span>
<span class="sd">            name {str} -- [description]</span>
<span class="sd">            length {float} -- [description]</span>
<span class="sd">            location {tuple} -- [description]</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            branchid {str} -- [description] (default: {&quot;not defined&quot;})</span>
<span class="sd">            chainage {int} -- [description] (default: {0})</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span> <span class="n">inifile</span><span class="o">=</span><span class="n">inifile</span><span class="p">)</span>

        <span class="c1"># Cross-section meta data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>  <span class="c1"># cross-section id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">length</span>  <span class="c1"># &#39;vaklengte&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">location</span> <span class="o">=</span> <span class="n">location</span>  <span class="c1"># (x,y)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">branch</span> <span class="o">=</span> <span class="n">branchid</span>  <span class="c1"># name of 1D branch for cross-section</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chainage</span> <span class="o">=</span> <span class="n">chainage</span>  <span class="c1"># offset from beginning of branch</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__output_mask_list</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># initialize output mask list.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fm_data</span> <span class="o">=</span> <span class="n">fm_data</span>  <span class="c1"># dictionary with fmdata</span>

        <span class="c1"># Cross-section geometry</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">total_width</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flow_width</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">section_widths</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;main&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;floodplain1&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;floodplain2&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">friction_tables</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">roughness_sections</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>

        <span class="c1"># delta h corrections (&quot;summerdike option&quot;)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">crest_level</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># in cross-section def. WAQ2PROF did crest - some fixed value.</span>
        <span class="c1">#  how to do here?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">floodplain_base</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="c1"># note&quot; &#39;to avoid numerical oscillation&#39;. might need minimal value.</span>
        <span class="c1"># fixed or variable? Test!</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transition_height</span> <span class="o">=</span> <span class="mf">0.5</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extra_flow_area</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extra_total_volume</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extra_area_percentage</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extra_total_area</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extra_flow_area</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># These attributes are used for non-reduced sets</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_css_z</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_css_total_volume</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_css_total_volume_corrected</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_css_flow_volume</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_css_flow_volume_corrected</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_css_total_width</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_css_flow_width</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_css_volume_legacy</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_css_index_of_first_nonzero</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fm_total_volume</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fm_flow_volume</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fm_wet_area</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fm_flow_area</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># flags</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_css_is_corrected</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_css_is_reduced</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># data structures</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__output_face_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__output_edge_list</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_section_map</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;1&quot;</span><span class="p">:</span> <span class="s2">&quot;main&quot;</span><span class="p">,</span>
            <span class="s2">&quot;2&quot;</span><span class="p">:</span> <span class="s2">&quot;floodplain1&quot;</span><span class="p">,</span>
            <span class="s2">&quot;3&quot;</span><span class="p">:</span> <span class="s2">&quot;floodplain2&quot;</span><span class="p">,</span>
            <span class="s2">&quot;-999&quot;</span><span class="p">:</span> <span class="s2">&quot;main&quot;</span><span class="p">,</span>
        <span class="p">}</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">alluvial_width</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="s2">&quot;main&quot;</span><span class="p">,</span> <span class="s2">&quot;Main&quot;</span><span class="p">]:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_widths</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nonalluvial_width</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">,</span> <span class="s2">&quot;floodplain&quot;</span><span class="p">,</span> <span class="s2">&quot;FloodPlain1&quot;</span><span class="p">]:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_widths</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">face_points_list</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__output_face_list</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">edge_points_list</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__output_edge_list</span>

    <span class="k">def</span> <span class="nf">get_point_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pointtype</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">pointtype</span> <span class="o">==</span> <span class="s2">&quot;face&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">face_points_list</span>
        <span class="k">elif</span> <span class="n">pointtype</span> <span class="o">==</span> <span class="s2">&quot;edge&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_points_list</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;pointtype must be &quot;face&quot; or &quot;edge&quot;&#39;</span><span class="p">)</span>

    <span class="c1"># Public functions</span>
    <span class="k">def</span> <span class="nf">build_geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build 1D geometrical cross-section from FM data.</span>

<span class="sd">        :param fm_data: dict</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fm_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fm_data</span>

        <span class="c1"># Unpack FM data</span>
        <span class="n">waterlevel</span> <span class="o">=</span> <span class="n">fm_data</span><span class="p">[</span><span class="s2">&quot;waterlevel&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span>
            <span class="p">:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_parameter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__cs_parameter_skip_maps</span><span class="p">)</span> <span class="p">:</span>
        <span class="p">]</span>
        <span class="n">waterdepth</span> <span class="o">=</span> <span class="n">fm_data</span><span class="p">[</span><span class="s2">&quot;waterdepth&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span>
            <span class="p">:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_parameter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__cs_parameter_skip_maps</span><span class="p">)</span> <span class="p">:</span>
        <span class="p">]</span>
        <span class="n">velocity</span> <span class="o">=</span> <span class="n">fm_data</span><span class="p">[</span><span class="s2">&quot;velocity&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span>
            <span class="p">:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_parameter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__cs_parameter_skip_maps</span><span class="p">)</span> <span class="p">:</span>
        <span class="p">]</span>
        <span class="n">area</span> <span class="o">=</span> <span class="n">fm_data</span><span class="p">[</span><span class="s2">&quot;area&quot;</span><span class="p">]</span>
        <span class="n">bedlevel</span> <span class="o">=</span> <span class="n">fm_data</span><span class="p">[</span><span class="s2">&quot;bedlevel&quot;</span><span class="p">]</span>

        <span class="c1"># Convert area to a matrix for matrix operations</span>
        <span class="c1"># (much more efficient than for-loops)</span>
        <span class="n">area_matrix</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">area</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">waterdepth</span><span class="p">:</span>
            <span class="n">area_matrix</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">area</span>

        <span class="n">bedlevel_matrix</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">bedlevel</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">waterdepth</span><span class="p">:</span>
            <span class="n">bedlevel_matrix</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">bedlevel</span>

        <span class="c1"># Retrieve the water-depth</span>
        <span class="c1"># &amp; water level nearest to the cross-section location</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_logger_message</span><span class="p">(</span><span class="s2">&quot;Retrieving centre point values&quot;</span><span class="p">)</span>
        <span class="p">(</span><span class="n">centre_depth</span><span class="p">,</span> <span class="n">centre_level</span><span class="p">)</span> <span class="o">=</span> <span class="n">FE</span><span class="o">.</span><span class="n">get_centre_values</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">location</span><span class="p">,</span> <span class="n">fm_data</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">],</span> <span class="n">fm_data</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">],</span> <span class="n">waterdepth</span><span class="p">,</span> <span class="n">waterlevel</span>
        <span class="p">)</span>

        <span class="c1"># apply rolling average over the velocities</span>
        <span class="c1"># to smooth out extreme values</span>
        <span class="n">velocity</span> <span class="o">=</span> <span class="n">velocity</span><span class="o">.</span><span class="n">rolling</span><span class="p">(</span>
            <span class="n">window</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">min_periods</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
        <span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>

        <span class="c1"># Identify river lakes (plassen)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_logger_message</span><span class="p">(</span><span class="s2">&quot;Identifying lakes&quot;</span><span class="p">)</span>
        <span class="p">(</span>
            <span class="n">plassen_mask</span><span class="p">,</span>
            <span class="n">wet_not_plas_mask</span><span class="p">,</span>
            <span class="n">plassen_depth_correction</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_identify_lakes</span><span class="p">(</span>
            <span class="n">waterdepth</span>
        <span class="p">)</span>  <span class="c1"># plassen_mask needed for arrays in output</span>

        <span class="c1"># Masks for wet and flow cells (stroomvoeringscriteria)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_logger_message</span><span class="p">(</span><span class="s2">&quot;Seperating flow from storage&quot;</span><span class="p">)</span>
        <span class="n">flow_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_distinguish_flow_from_storage</span><span class="p">(</span><span class="n">waterdepth</span><span class="p">,</span> <span class="n">velocity</span><span class="p">)</span>

        <span class="c1"># Calculate area and volume as function of waterlevel &amp; waterdepth</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fm_wet_area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">area_matrix</span><span class="p">[</span><span class="n">wet_not_plas_mask</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fm_flow_area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">area_matrix</span><span class="p">[</span><span class="n">flow_mask</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Correct waterdepth for lakes</span>
        <span class="n">waterdepth</span> <span class="o">=</span> <span class="n">waterdepth</span> <span class="o">+</span> <span class="n">plassen_depth_correction</span>
        <span class="n">waterdepth</span> <span class="o">=</span> <span class="n">waterdepth</span><span class="p">[</span><span class="n">waterdepth</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Correct waterdepth for deep pools (volume below deepest point in centre</span>
        <span class="c1"># should not be considered to be conveyance)</span>
        <span class="n">pools_id</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">waterdepth</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">centre_depth</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="p">]</span>
        <span class="k">for</span> <span class="n">pool</span> <span class="ow">in</span> <span class="n">pools_id</span><span class="p">:</span>
            <span class="n">amount_deeper</span> <span class="o">=</span> <span class="n">waterdepth</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">pool</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">centre_depth</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">waterdepth</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">pool</span><span class="p">]</span> <span class="o">-=</span> <span class="n">amount_deeper</span>

        <span class="c1"># waterdepth[waterdepth &gt; centre_depth[0]] = centre_depth[0]</span>

        <span class="c1"># Compute 2D volume as sum of area times depth</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fm_total_volume</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span>
                <span class="n">area_matrix</span><span class="p">[</span><span class="n">wet_not_plas_mask</span><span class="p">]</span> <span class="o">*</span> <span class="n">waterdepth</span><span class="p">[</span><span class="n">wet_not_plas_mask</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fm_flow_volume</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">area_matrix</span><span class="p">[</span><span class="n">flow_mask</span><span class="p">]</span> <span class="o">*</span> <span class="n">waterdepth</span><span class="p">[</span><span class="n">flow_mask</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># For roughness we will need the original z-levels,</span>
        <span class="c1"># since geometry z will change below</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_css_z_roughness</span> <span class="o">=</span> <span class="n">centre_level</span>

        <span class="c1"># Check for monotonicity (water levels should rise)</span>
        <span class="n">mono_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_monotonicity</span><span class="p">(</span><span class="n">centre_level</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">centre_level</span> <span class="o">=</span> <span class="n">centre_level</span><span class="p">[</span><span class="n">mono_mask</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fm_total_volume</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fm_total_volume</span><span class="p">[</span><span class="n">mono_mask</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fm_flow_volume</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fm_flow_volume</span><span class="p">[</span><span class="n">mono_mask</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fm_wet_area</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fm_wet_area</span><span class="p">[</span><span class="n">mono_mask</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fm_flow_area</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fm_flow_area</span><span class="p">[</span><span class="n">mono_mask</span><span class="p">]</span>

        <span class="c1"># Compute geometry above z0 - Water level dependent calculation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_logger_message</span><span class="p">(</span><span class="s2">&quot;Computing cross-section from water levels&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compute_css_above_z0</span><span class="p">(</span><span class="n">centre_level</span><span class="p">)</span>

        <span class="c1"># Compute geometry below z0 - Water level independent calculation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_logger_message</span><span class="p">(</span><span class="s2">&quot;Computing cross-section from bed levels&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_extend_css_below_z0</span><span class="p">(</span>
            <span class="n">centre_level</span><span class="p">,</span>
            <span class="n">centre_depth</span><span class="p">,</span>
            <span class="n">waterlevel</span><span class="p">,</span>
            <span class="n">bedlevel_matrix</span><span class="p">,</span>
            <span class="n">area_matrix</span><span class="p">,</span>
            <span class="n">wet_not_plas_mask</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Compute 1D volume as integral of width with respect to z times length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_css_total_volume</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cumtrapz</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_css_total_width</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_css_z</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_css_flow_volume</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cumtrapz</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_css_flow_width</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_css_z</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span>
        <span class="p">)</span>

        <span class="c1"># If sd correction is run, these attributes will be updated.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_css_total_volume_corrected</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_css_total_volume</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_css_flow_volume_corrected</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_css_flow_volume</span>

        <span class="c1"># convert to float64 array for uniformity</span>
        <span class="c1"># (apparently entries can be float32)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_css_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_css_z</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;float64&quot;</span><span class="p">))</span>

        <span class="n">fm_data</span><span class="p">[</span><span class="s2">&quot;islake&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">plassen_mask</span>

        <span class="c1"># generate all mask points for the given cross_section</span>
        <span class="c1"># self.set_mask_output_list(fm_data, plassen_mask)</span>

    <span class="k">def</span> <span class="nf">check_requirements</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs check on cross-section such that it</span>
<span class="sd">        hold up to requirements.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Remove multiple zeroes in the bottom of the cross-section</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_css_index_of_first_nonzero</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_remove_duplicate_zeroes</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_css_total_width</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_remove_zero_widths</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_css_total_width</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_css_flow_width</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_remove_zero_widths</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_css_flow_width</span><span class="p">)</span>

        <span class="c1"># Check if cross-sections are in increasing order</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_css_z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_increasing_order</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_css_z</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_css_total_width</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_increasing_order</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_css_total_width</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_css_flow_width</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_increasing_order</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_css_flow_width</span><span class="p">)</span>

        <span class="c1"># Check if total width is larger than flow width</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_total_width_greater_than_flow_width</span><span class="p">()</span>

        <span class="c1"># Check if section widths combined are not smaller than flow width</span>
        <span class="c1"># self._check_section_widths_greater_than_flow_width()</span>

<div class="viewcode-block" id="CrossSection.calculate_correction"><a class="viewcode-back" href="../../chapters/technical_manual/numerical_methods.html#fm2prof.CrossSection.CrossSection.calculate_correction">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_correction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transition_height</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method computes a volume correction that cannot be captured within the</span>
<span class="sd">        constraints of 1D cross-sectional geometry, which forces an increasing width</span>
<span class="sd">        at increasing elevation and cannot deal with varying water levels. In reality,</span>
<span class="sd">        compartimentation of floodplains can cause a sudden</span>
<span class="sd">        increase of volume while the water level does not increase.</span>

<span class="sd">        Technically, the derivative of the volume over elevation (dV/dz) must be</span>
<span class="sd">        monotonically increasing, meaning it cannot increase slower than it did</span>
<span class="sd">        at a lower z. However, this is exactly what happens with compartimentalisation,</span>
<span class="sd">        see (see :term:`Summerdikes`).</span>

<span class="sd">        This method computes input for the &#39;summerdike&#39; option in SOBEK, which requires three variables:</span>

<span class="sd">        - The crest level of the summerdike</span>
<span class="sd">        - The total volume behind the summerdike</span>
<span class="sd">        - The total volume behind the summerdike</span>
<span class="sd">        - The :ref:`transition height &lt;parameter_sdtransitionheight&gt;`</span>
<span class="sd">          over which the volumes are added to the geometry. This variable is set globally.</span>

<span class="sd">        We refer to the SOBEK technical manual for details on the implementation.</span>

<span class="sd">        The algorithm works as follows:</span>

<span class="sd">        1. The initial attributes (crest and volumes) are set and outputted (in debug mode)</span>
<span class="sd">        2. Optimise the attributes by minimising the cost function. For the cost function we</span>
<span class="sd">           use the squared relative error. The parameter :ref:`SDOptimisationMethod&lt;parameter_sdoptimisationmethod&gt;`</span>
<span class="sd">           is used to determine which output variables are used to compute the error.</span>
<span class="sd">        3. Add the extra volume to the css volume given the water level (see note below)</span>

<span class="sd">        .. note::</span>
<span class="sd">            In SOBEK, the extra volume is released following a polynomial function. In |project|, we approximate</span>
<span class="sd">            this with the following logistic function:</span>

<span class="sd">            :math:`C(h_k)=\Xi(1+e^{\log(\delta)\\tau^{-1}(h_k-(\gamma+\\tau/2))})^{-1}`</span>

<span class="sd">            where :math:`\Xi` is the volume correction (m3/s), :math:`\\tau` is the transition height,</span>
<span class="sd">            :math:`\delta` is an accuracy parameter, :math:`\gamma` is the crest level, and :math:`C(h_k)`</span>
<span class="sd">            is the added volume given water level :math:`h_k`. The default value of :math:`\delta` is</span>
<span class="sd">            0.00001, and not configurable.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Set initial values for optimisation of parameters</span>
        <span class="n">initial_total_error</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_css_total_volume</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fm_total_volume</span>
        <span class="n">initial_flow_error</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_css_flow_volume</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fm_flow_volume</span>

        <span class="n">initial_crest</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_css_z</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nanargmin</span><span class="p">(</span><span class="n">initial_total_error</span><span class="p">)]</span>
        <span class="n">initial_total_volume</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">initial_total_error</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">initial_flow_volume</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">initial_flow_error</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_logger_message</span><span class="p">(</span>
            <span class="s2">&quot;Initial crest: </span><span class="si">{:.4f}</span><span class="s2"> m&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">initial_crest</span><span class="p">),</span> <span class="n">level</span><span class="o">=</span><span class="s2">&quot;debug&quot;</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_logger_message</span><span class="p">(</span>
            <span class="s2">&quot;Initial extra total area: </span><span class="si">{:.4f}</span><span class="s2"> m2&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">initial_total_volume</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span>
            <span class="p">),</span>
            <span class="n">level</span><span class="o">=</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_logger_message</span><span class="p">(</span>
            <span class="s2">&quot;Initial extra flow area: </span><span class="si">{:.4f}</span><span class="s2"> m2&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">initial_flow_volume</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span>
            <span class="p">),</span>
            <span class="n">level</span><span class="o">=</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Optimise attributes</span>
        <span class="n">opt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_optimize_sd_storage</span><span class="p">(</span>
            <span class="n">initial_crest</span><span class="o">=</span><span class="n">initial_crest</span><span class="p">,</span>
            <span class="n">initial_total_volume</span><span class="o">=</span><span class="n">initial_total_volume</span><span class="p">,</span>
            <span class="n">initial_flow_volume</span><span class="o">=</span><span class="n">initial_flow_volume</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Unpack optimisation results</span>
        <span class="n">transition_height</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_parameter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__cs_parameter_transitionheight_sd</span><span class="p">)</span>
        <span class="n">crest_level</span> <span class="o">=</span> <span class="n">opt</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;crest_level&quot;</span><span class="p">)</span>
        <span class="n">extra_total_volume</span> <span class="o">=</span> <span class="n">opt</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;extra_total_volume&quot;</span><span class="p">)</span>
        <span class="n">extra_flow_volume</span> <span class="o">=</span> <span class="n">opt</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;extra_flow_volume&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_logger_message</span><span class="p">(</span>
            <span class="s2">&quot;final costs: </span><span class="si">{:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">opt</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;final_cost&quot;</span><span class="p">)),</span> <span class="n">level</span><span class="o">=</span><span class="s2">&quot;debug&quot;</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_logger_message</span><span class="p">(</span>
            <span class="s2">&quot;Optimizer msg: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">opt</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;message&quot;</span><span class="p">)),</span> <span class="n">level</span><span class="o">=</span><span class="s2">&quot;debug&quot;</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_logger_message</span><span class="p">(</span>
            <span class="s2">&quot;Final crest: </span><span class="si">{:.4f}</span><span class="s2"> m&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">crest_level</span><span class="p">),</span> <span class="n">level</span><span class="o">=</span><span class="s2">&quot;debug&quot;</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_logger_message</span><span class="p">(</span>
            <span class="s2">&quot;Final total area: </span><span class="si">{:.4f}</span><span class="s2"> m2&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">extra_total_volume</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">),</span>
            <span class="n">level</span><span class="o">=</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_logger_message</span><span class="p">(</span>
            <span class="s2">&quot;Final flow area: </span><span class="si">{:.4f}</span><span class="s2"> m2&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">extra_flow_volume</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">),</span>
            <span class="n">level</span><span class="o">=</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">extra_area_percentage</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_extra_total_area</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_css_z</span><span class="p">,</span> <span class="n">crest_level</span><span class="p">,</span> <span class="n">transition_height</span>
        <span class="p">)</span>

        <span class="c1"># Write to attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_css_total_volume_corrected</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_css_total_volume</span> <span class="o">+</span> <span class="n">extra_area_percentage</span> <span class="o">*</span> <span class="n">extra_total_volume</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_css_flow_volume_corrected</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_css_flow_volume</span> <span class="o">+</span> <span class="n">extra_area_percentage</span> <span class="o">*</span> <span class="n">extra_flow_volume</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">crest_level</span> <span class="o">=</span> <span class="n">crest_level</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transition_height</span> <span class="o">=</span> <span class="n">transition_height</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extra_total_volume</span> <span class="o">=</span> <span class="n">extra_total_volume</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extra_flow_volume</span> <span class="o">=</span> <span class="n">extra_flow_volume</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extra_total_area</span> <span class="o">=</span> <span class="n">extra_total_volume</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extra_flow_area</span> <span class="o">=</span> <span class="n">extra_flow_volume</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extra_area_percentage</span> <span class="o">=</span> <span class="n">extra_area_percentage</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_css_is_corrected</span> <span class="o">=</span> <span class="kc">True</span></div>

    <span class="k">def</span> <span class="nf">assign_roughness</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function builds a table of Chezy values as function of water level</span>
<span class="sd">        The roughnes is divides into two sections on the assumption of</span>
<span class="sd">        an alluvial (smooth) and nonalluvial (rough) part of the total</span>
<span class="sd">        cross-section. This division is made based on the final timestep.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Compute roughness tabels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_logger_message</span><span class="p">(</span><span class="s2">&quot;Building roughness table&quot;</span><span class="p">,</span> <span class="s2">&quot;debug&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_build_roughness_tables</span><span class="p">()</span>
        <span class="c1"># Compute roughness widths</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_logger_message</span><span class="p">(</span><span class="s2">&quot;Computing section widths&quot;</span><span class="p">,</span> <span class="s2">&quot;debug&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compute_section_widths</span><span class="p">()</span>
        <span class="c1"># Compute floodplain base level</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_logger_message</span><span class="p">(</span><span class="s2">&quot;Computing base level&quot;</span><span class="p">,</span> <span class="s2">&quot;debug&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compute_floodplain_base</span><span class="p">()</span>
        <span class="c1"># done</span>

    <span class="k">def</span> <span class="nf">get_number_of_faces</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;use this method to return the number of 2D faces within control volume&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fm_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">get_number_of_vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Use this method to return the current number of geometry vertices&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_css_total_width</span><span class="p">)</span>

<div class="viewcode-block" id="CrossSection.reduce_points"><a class="viewcode-back" href="../../chapters/technical_manual/numerical_methods.html#fm2prof.CrossSection.CrossSection.reduce_points">[docs]</a>    <span class="k">def</span> <span class="nf">reduce_points</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">count_after</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;visvalingam_whyatt&quot;</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The cross-section geometry generated by |project| contains one point per output</span>
<span class="sd">        timestep in the 2D map file. This resolution is often too high given the</span>
<span class="sd">        complexity of the cross-sections, and results in very large input files for the</span>
<span class="sd">        1D model. Therefore |project| includes a simplification algorithm that reduces</span>
<span class="sd">        the number of points while preservering the shape of the geometry. This algorithm</span>
<span class="sd">        reduces as many points until the number specified in</span>
<span class="sd">        :ref:`MaximumPointsInProfile&lt;parameter_maximumpointsinprofile&gt;` is reached.</span>
<span class="sd">        We use the Visvalingam-Whyatt method of poly-line vertex reduction [VW]_.</span>
<span class="sd">        The :term:`Total width` is leading for the simplification of the geometry meaning</span>
<span class="sd">        that the choice for which points to remove to simplify the geometry is based on</span>
<span class="sd">        the total width. Subsequently, the corresponding point are removed from the :term:`Flow width`.</span>

<span class="sd">        .. [VW] Visvalingam, M and Whyatt J D (1993) &quot;Line Generalisation by Repeated Elimination of Points&quot;, Cartographic J., 30 (1), 46 - 51 URL: http://web.archive.org/web/20100428020453/http://www2.dcs.hull.ac.uk/CISRG/publications/DPs/DP10/DP10.html</span>
<span class="sd">                Implemented vertex reduction methods:</span>

<span class="sd">        Args:</span>
<span class="sd">            n (int): asdf</span>
<span class="sd">            method (str): asdf</span>
<span class="sd">            verbose (bool): asdf</span>

<span class="sd">        Returns:</span>
<span class="sd">            None: This method directly works on the object attributes</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">n_before_reduction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_number_of_vertices</span><span class="p">()</span>

        <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_css_z</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_css_total_width</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_before_reduction</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># The number of points is equal to n, it cannot be further reduced</span>
        <span class="n">reduced_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="kc">True</span><span class="p">]</span> <span class="o">*</span> <span class="n">n_before_reduction</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">n_before_reduction</span> <span class="o">&gt;</span> <span class="n">count_after</span><span class="p">:</span>
            <span class="c1"># default is the same value as it came</span>
            <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;visvalingam_whyatt&quot;</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">simplifier</span> <span class="o">=</span> <span class="n">PS</span><span class="o">.</span><span class="n">VWSimplifier</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
                    <span class="n">reduced_index</span> <span class="o">=</span> <span class="n">simplifier</span><span class="o">.</span><span class="n">from_number_index</span><span class="p">(</span><span class="n">count_after</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">set_logger_message</span><span class="p">(</span>
                        <span class="s2">&quot;Exception thrown while using polysimplify: &quot;</span>
                        <span class="o">+</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)),</span>
                        <span class="s2">&quot;error&quot;</span><span class="p">,</span>
                    <span class="p">)</span>

        <span class="c1"># Write to attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_css_z</span><span class="p">[</span><span class="n">reduced_index</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">total_width</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_css_total_width</span><span class="p">[</span><span class="n">reduced_index</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flow_width</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_css_flow_width</span><span class="p">[</span><span class="n">reduced_index</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_logger_message</span><span class="p">(</span>
            <span class="s2">&quot;Cross-section reduced &quot;</span>
            <span class="o">+</span> <span class="s2">&quot;from </span><span class="si">{}</span><span class="s2"> &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n_before_reduction</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot;to </span><span class="si">{}</span><span class="s2"> points&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">total_width</span><span class="p">))</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_css_is_reduced</span> <span class="o">=</span> <span class="kc">True</span></div>

    <span class="k">def</span> <span class="nf">set_face_output_list</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a list of output mask points based on</span>
<span class="sd">        their values in the mask.</span>

<span class="sd">        writes to self.__output_mask_list</span>

<span class="sd">        Paramters:</span>
<span class="sd">            fm_data {dict} -- Dictionary containing x,y values.</span>
<span class="sd">            mask_array {NP.array} -- Array of values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fm_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fm_data</span>

        <span class="c1"># Properties keys</span>
        <span class="n">cross_section_id_key</span> <span class="o">=</span> <span class="s2">&quot;cross_section_id&quot;</span>
        <span class="n">cross_section_region_key</span> <span class="o">=</span> <span class="s2">&quot;region&quot;</span>
        <span class="n">is_lake_key</span> <span class="o">=</span> <span class="s2">&quot;is_lake&quot;</span>
        <span class="n">bedlevel_key</span> <span class="o">=</span> <span class="s2">&quot;bedlevel&quot;</span>
        <span class="n">section_key</span> <span class="o">=</span> <span class="s2">&quot;section&quot;</span>
        <span class="n">region_key</span> <span class="o">=</span> <span class="s2">&quot;region&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Normalize np arrays to list for correct access</span>
            <span class="n">x_coords</span> <span class="o">=</span> <span class="n">fm_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">y_coords</span> <span class="o">=</span> <span class="n">fm_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">region_list</span> <span class="o">=</span> <span class="n">fm_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;region&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">section_list</span> <span class="o">=</span> <span class="n">fm_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;section&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">bedlevel_list</span> <span class="o">=</span> <span class="n">fm_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;bedlevel&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">is_lake_mask_list</span> <span class="o">=</span> <span class="n">fm_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;islake&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

            <span class="c1"># Assume same length for x and y coords.</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x_coords</span><span class="p">)):</span>
                <span class="n">mask_properties</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="n">cross_section_id_key</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                    <span class="n">is_lake_key</span><span class="p">:</span> <span class="n">is_lake_mask_list</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                    <span class="n">cross_section_region_key</span><span class="p">:</span> <span class="n">region_list</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                    <span class="n">bedlevel_key</span><span class="p">:</span> <span class="n">bedlevel_list</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                    <span class="n">region_key</span><span class="p">:</span> <span class="n">region_list</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                    <span class="n">section_key</span><span class="p">:</span> <span class="n">section_list</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                <span class="p">}</span>
                <span class="n">mask_coords</span> <span class="o">=</span> <span class="p">(</span><span class="n">x_coords</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">y_coords</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="c1"># Create the actual geojson element.</span>
                <span class="n">output_mask</span> <span class="o">=</span> <span class="n">MaskOutputFile</span><span class="o">.</span><span class="n">create_mask_point</span><span class="p">(</span>
                    <span class="n">mask_coords</span><span class="p">,</span> <span class="n">mask_properties</span>
                <span class="p">)</span>

                <span class="k">if</span> <span class="n">output_mask</span><span class="o">.</span><span class="n">is_valid</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__output_face_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">output_mask</span><span class="p">)</span>
                    <span class="c1"># self.set_logger_message(</span>
                    <span class="c1">#    &#39;Added output mask at {} &#39;.format(mask_coords) +</span>
                    <span class="c1">#    &#39;for Cross Section {}.&#39;.format(self.name),</span>
                    <span class="c1">#     level=&#39;debug&#39;)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">set_logger_message</span><span class="p">(</span>
                        <span class="s2">&quot;Invalid output mask at </span><span class="si">{}</span><span class="s2"> &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mask_coords</span><span class="p">)</span>
                        <span class="o">+</span> <span class="s2">&quot;for Cross Section </span><span class="si">{}</span><span class="s2">, not added. &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                        <span class="o">+</span> <span class="s2">&quot;Reason </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">output_mask</span><span class="o">.</span><span class="n">errors</span><span class="p">()),</span>
                        <span class="n">level</span><span class="o">=</span><span class="s2">&quot;error&quot;</span><span class="p">,</span>
                    <span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e_error</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_logger_message</span><span class="p">(</span>
                <span class="s2">&quot;Error setting output masks &quot;</span>
                <span class="o">+</span> <span class="s2">&quot;for Cross Section </span><span class="si">{}</span><span class="s2">. &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="o">+</span> <span class="s2">&quot;Reason: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">e_error</span><span class="p">)),</span>
                <span class="n">level</span><span class="o">=</span><span class="s2">&quot;error&quot;</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_edge_output_list</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a list of output mask points based on</span>
<span class="sd">        their values in the mask.</span>

<span class="sd">        writes to self.__output_mask_list</span>

<span class="sd">        Parameters:</span>
<span class="sd">            fm_data {dict} -- Dictionary containing x,y values.</span>
<span class="sd">            mask_array {NP.array} -- Array of values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fm_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fm_data</span>

        <span class="c1"># Properties keys</span>
        <span class="n">cross_section_id_key</span> <span class="o">=</span> <span class="s2">&quot;cross_section_id&quot;</span>
        <span class="n">cross_section_region_key</span> <span class="o">=</span> <span class="s2">&quot;region&quot;</span>
        <span class="n">roughness_section_key</span> <span class="o">=</span> <span class="s2">&quot;section&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Normalize np arrays to list for correct access</span>
            <span class="n">x_coords</span> <span class="o">=</span> <span class="n">fm_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;edge_x&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">y_coords</span> <span class="o">=</span> <span class="n">fm_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;edge_y&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">section_list</span> <span class="o">=</span> <span class="n">fm_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;edge_section&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="c1"># Assume same length for x and y coords.</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x_coords</span><span class="p">)):</span>
                <span class="n">mask_properties</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="n">cross_section_id_key</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                    <span class="n">roughness_section_key</span><span class="p">:</span> <span class="n">section_list</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                <span class="p">}</span>
                <span class="n">mask_coords</span> <span class="o">=</span> <span class="p">(</span><span class="n">x_coords</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">y_coords</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="c1"># Create the actual geojson element.</span>
                <span class="n">output_mask</span> <span class="o">=</span> <span class="n">MaskOutputFile</span><span class="o">.</span><span class="n">create_mask_point</span><span class="p">(</span>
                    <span class="n">mask_coords</span><span class="p">,</span> <span class="n">mask_properties</span>
                <span class="p">)</span>

                <span class="k">if</span> <span class="n">output_mask</span><span class="o">.</span><span class="n">is_valid</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__output_edge_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">output_mask</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">set_logger_message</span><span class="p">(</span>
                        <span class="s2">&quot;Invalid output mask at </span><span class="si">{}</span><span class="s2"> &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mask_coords</span><span class="p">)</span>
                        <span class="o">+</span> <span class="s2">&quot;for Cross Section </span><span class="si">{}</span><span class="s2">, not added. &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                        <span class="o">+</span> <span class="s2">&quot;Reason </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">output_mask</span><span class="o">.</span><span class="n">errors</span><span class="p">()),</span>
                        <span class="n">level</span><span class="o">=</span><span class="s2">&quot;error&quot;</span><span class="p">,</span>
                    <span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e_error</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_logger_message</span><span class="p">(</span>
                <span class="s2">&quot;Error setting output masks &quot;</span>
                <span class="o">+</span> <span class="s2">&quot;for Cross Section </span><span class="si">{}</span><span class="s2">. &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="o">+</span> <span class="s2">&quot;Reason: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">e_error</span><span class="p">)),</span>
                <span class="n">level</span><span class="o">=</span><span class="s2">&quot;error&quot;</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">interpolate_roughness_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tablename</span><span class="p">,</span> <span class="n">z_values</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Interpolates the roughness table to z values</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">table_name_list</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;main&quot;</span><span class="p">,</span> <span class="s2">&quot;floodplain1&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">tablename</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">table_name_list</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;tablename not in list </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">table_name_list</span><span class="p">))</span>

        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">_check_remove_duplicate_zeroes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes duplicate zeroes in the total width</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="kc">True</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_css_z</span><span class="p">))</span>

        <span class="c1"># Remove multiple 0s in the total width</span>
        <span class="n">index_of_first_nonzero</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_css_total_width</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">index_of_first_nonzero</span>

        <span class="c1"># self._css_z = self._return_first_item_and_after_index(self._css_z, index_of_first_nonzero)</span>
        <span class="c1"># self._css_flow_width = self._return_first_item_and_after_index(self._css_flow_width, index_of_first_nonzero)</span>
        <span class="c1"># self._css_total_width = self._return_first_item_and_after_index(self._css_total_width, index_of_first_nonzero)</span>
        <span class="c1"># self.set_logger_message(f&#39;Removed {index_of_first_nonzero-1} duplicate zero widths&#39;, &#39;debug&#39;)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_return_first_item_and_after_index</span><span class="p">(</span><span class="n">listin</span><span class="p">,</span> <span class="n">after_index</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">listin</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">listin</span><span class="p">[</span><span class="n">after_index</span><span class="p">:]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">_check_remove_zero_widths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">width_array</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A zero width may lead to numerical instability</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">minwidth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_parameter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__cs_parameter_minwidth</span><span class="p">)</span>
        <span class="n">width_array</span><span class="p">[</span><span class="n">width_array</span> <span class="o">&lt;</span> <span class="n">minwidth</span><span class="p">]</span> <span class="o">=</span> <span class="n">minwidth</span>

        <span class="k">return</span> <span class="n">width_array</span>

    <span class="k">def</span> <span class="nf">_combined_optimisation_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">opt_in</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cost function, combines total volume error and flow volume error</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">crest_level</span><span class="p">,</span> <span class="n">extra_total_volume</span><span class="p">,</span> <span class="n">extra_flow_volume</span><span class="p">)</span> <span class="o">=</span> <span class="n">opt_in</span>
        <span class="n">transition_height</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_parameter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__cs_parameter_transitionheight_sd</span><span class="p">)</span>

        <span class="n">predicted_total_volume</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_css_total_volume</span>
            <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_extra_total_area</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_css_z</span><span class="p">,</span> <span class="n">crest_level</span><span class="p">,</span> <span class="n">transition_height</span><span class="p">)</span>
            <span class="o">*</span> <span class="n">extra_total_volume</span>
        <span class="p">)</span>

        <span class="n">predicted_flow_volume</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_css_flow_volume</span>
            <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_extra_total_area</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_css_z</span><span class="p">,</span> <span class="n">crest_level</span><span class="p">,</span> <span class="n">transition_height</span><span class="p">)</span>
            <span class="o">*</span> <span class="n">extra_flow_volume</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__return_volume_error</span><span class="p">(</span>
            <span class="n">predicted_total_volume</span> <span class="o">+</span> <span class="n">predicted_flow_volume</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fm_total_volume</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fm_flow_volume</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_optimisation_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">opt_in</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Objective function used in optimising a delta-h correction</span>
<span class="sd">        for parameters:</span>
<span class="sd">            crest_level         : level at which the correction begins</span>
<span class="sd">            transition_height   : height over which volume is released</span>
<span class="sd">            extra_volume        : total extra volume</span>


<span class="sd">        :param opt_in: tuple</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;both&quot;</span><span class="p">:</span>
            <span class="p">(</span><span class="n">crest_level</span><span class="p">,</span> <span class="n">extra_volume</span><span class="p">)</span> <span class="o">=</span> <span class="n">opt_in</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="p">(</span><span class="n">extra_volume</span><span class="p">)</span> <span class="o">=</span> <span class="n">opt_in</span>
            <span class="n">crest_level</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>

        <span class="n">volume</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">transition_height</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_parameter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__cs_parameter_transitionheight_sd</span><span class="p">)</span>

        <span class="n">predicted_volume</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">volume</span>
            <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_extra_total_area</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_css_z</span><span class="p">,</span> <span class="n">crest_level</span><span class="p">,</span> <span class="n">transition_height</span><span class="p">)</span>
            <span class="o">*</span> <span class="n">extra_volume</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__return_volume_error</span><span class="p">(</span><span class="n">predicted_volume</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fm_total_volume</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_optimize_sd_storage</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">initial_crest</span><span class="p">,</span> <span class="n">initial_total_volume</span><span class="p">,</span> <span class="n">initial_flow_volume</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Optimised the crest level and volumes</span>

<span class="sd">        Returns:</span>
<span class="sd">            Dictionary with optimised values, final cost and optimisation message</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Default option</span>
        <span class="n">sdoptimisationmethod</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_parameter</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__cs_parameter_sdoptimisationmethod</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">sdoptimisationmethod</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]:</span>
            <span class="c1"># this should be handled in inifile instead</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_logger_message</span><span class="p">(</span>
                <span class="s2">&quot;sdoptimisationmethod is </span><span class="si">{}</span><span class="s2"> but should be 0, 1, or 2. Defaulting to 0&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">sdoptimisationmethod</span>
                <span class="p">),</span>
                <span class="n">level</span><span class="o">=</span><span class="s2">&quot;warning&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">sdoptimisationmethod</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">sdoptimisationmethod</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_logger_message</span><span class="p">(</span><span class="s2">&quot;Optimising SD on total volume&quot;</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="s2">&quot;debug&quot;</span><span class="p">)</span>

            <span class="c1"># Optimise crest on total volume</span>
            <span class="n">opt</span> <span class="o">=</span> <span class="n">so</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_optimisation_func</span><span class="p">,</span>
                <span class="p">(</span><span class="n">initial_crest</span><span class="p">,</span> <span class="n">initial_total_volume</span><span class="p">),</span>
                <span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;both&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_css_total_volume</span><span class="p">],</span>
                <span class="n">method</span><span class="o">=</span><span class="s2">&quot;Nelder-Mead&quot;</span><span class="p">,</span>
                <span class="n">tol</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="n">crest_level</span> <span class="o">=</span> <span class="n">opt</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">extra_total_volume</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">opt</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">])</span>

            <span class="c1"># Optimise flow volume</span>
            <span class="n">opt2</span> <span class="o">=</span> <span class="n">so</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_optimisation_func</span><span class="p">,</span>
                <span class="p">(</span><span class="n">initial_flow_volume</span><span class="p">),</span>
                <span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;notboth&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_css_flow_volume</span><span class="p">,</span> <span class="n">crest_level</span><span class="p">],</span>
                <span class="n">method</span><span class="o">=</span><span class="s2">&quot;Nelder-Mead&quot;</span><span class="p">,</span>
                <span class="n">tol</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">extra_flow_volume</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">opt2</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">extra_total_volume</span><span class="p">])</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_parameter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__cs_parameter_sdoptimisationmethod</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_logger_message</span><span class="p">(</span><span class="s2">&quot;Optimising SD on flow volume&quot;</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="s2">&quot;debug&quot;</span><span class="p">)</span>

            <span class="c1"># Optimise crest on flow volume</span>
            <span class="n">opt</span> <span class="o">=</span> <span class="n">so</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_optimisation_func</span><span class="p">,</span>
                <span class="p">(</span><span class="n">initial_crest</span><span class="p">,</span> <span class="n">initial_total_volume</span><span class="p">),</span>
                <span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;both&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_css_flow_volume</span><span class="p">],</span>
                <span class="n">method</span><span class="o">=</span><span class="s2">&quot;Nelder-Mead&quot;</span><span class="p">,</span>
                <span class="n">tol</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">crest_level</span> <span class="o">=</span> <span class="n">opt</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">extra_flow_volume</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">opt</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">])</span>

            <span class="c1"># Optimise total volume</span>
            <span class="n">opt2</span> <span class="o">=</span> <span class="n">so</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_optimisation_func</span><span class="p">,</span>
                <span class="p">(</span><span class="n">initial_flow_volume</span><span class="p">),</span>
                <span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;notboth&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_css_total_volume</span><span class="p">,</span> <span class="n">crest_level</span><span class="p">],</span>
                <span class="n">method</span><span class="o">=</span><span class="s2">&quot;Nelder-Mead&quot;</span><span class="p">,</span>
                <span class="n">tol</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">extra_total_volume</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">opt2</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">extra_flow_volume</span><span class="p">])</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_parameter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__cs_parameter_sdoptimisationmethod</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_logger_message</span><span class="p">(</span>
                <span class="s2">&quot;Optimising SD on both flow and total volumes&quot;</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="s2">&quot;debug&quot;</span>
            <span class="p">)</span>
            <span class="n">opt</span> <span class="o">=</span> <span class="n">so</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_combined_optimisation_func</span><span class="p">,</span>
                <span class="p">(</span><span class="n">initial_crest</span><span class="p">,</span> <span class="n">initial_total_volume</span><span class="p">,</span> <span class="n">initial_flow_volume</span><span class="p">),</span>
                <span class="n">method</span><span class="o">=</span><span class="s2">&quot;Nelder-Mead&quot;</span><span class="p">,</span>
                <span class="n">tol</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="n">crest_level</span> <span class="o">=</span> <span class="n">opt</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">extra_total_volume</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">opt</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">])</span>
            <span class="n">extra_flow_volume</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">opt</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">extra_total_volume</span><span class="p">])</span>

        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;crest_level&quot;</span><span class="p">:</span> <span class="n">crest_level</span><span class="p">,</span>
            <span class="s2">&quot;extra_total_volume&quot;</span><span class="p">:</span> <span class="n">extra_total_volume</span><span class="p">,</span>
            <span class="s2">&quot;extra_flow_volume&quot;</span><span class="p">:</span> <span class="n">extra_flow_volume</span><span class="p">,</span>
            <span class="s2">&quot;final_cost&quot;</span><span class="p">:</span> <span class="n">opt</span><span class="p">[</span><span class="s2">&quot;fun&quot;</span><span class="p">],</span>
            <span class="s2">&quot;message&quot;</span><span class="p">:</span> <span class="n">opt</span><span class="p">[</span><span class="s2">&quot;message&quot;</span><span class="p">],</span>
        <span class="p">}</span>

    <span class="k">def</span> <span class="nf">_check_increasing_order</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">list_points</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;runs&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">list_points</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">list_points</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">list_points</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="n">list_points</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">list_points</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.001</span>
        <span class="k">return</span> <span class="n">list_points</span>

    <span class="k">def</span> <span class="nf">_build_roughness_tables</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="c1"># Find roughness tables for each section</span>
        <span class="n">chezy_fm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fm_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;chezy&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span>
            <span class="p">:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_parameter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__cs_parameter_skip_maps</span><span class="p">)</span> <span class="p">:</span>
        <span class="p">]</span>

        <span class="n">sections</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fm_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;edge_section&quot;</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">section</span> <span class="ow">in</span> <span class="n">sections</span><span class="p">:</span>
            <span class="n">chezy_section</span> <span class="o">=</span> <span class="n">chezy_fm</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_fm_data</span><span class="p">[</span><span class="s2">&quot;edge_section&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">section</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_parameter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__cs_parameter_Frictionweighing</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">friction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_friction_weighing_simple</span><span class="p">(</span><span class="n">chezy_section</span><span class="p">,</span> <span class="n">section</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_parameter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__cs_parameter_Frictionweighing</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">friction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_friction_weighing_area</span><span class="p">(</span><span class="n">chezy_section</span><span class="p">,</span> <span class="n">section</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;unknown option for roughness weighing: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">get_parameter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__cs_parameter_Frictionweighing</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">friction_tables</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_section_map</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">section</span><span class="p">)]]</span> <span class="o">=</span> <span class="n">FrictionTable</span><span class="p">(</span>
                <span class="n">level</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_css_z_roughness</span><span class="p">,</span> <span class="n">friction</span><span class="o">=</span><span class="n">friction</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_friction_weighing_simple</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">link_chezy</span><span class="p">,</span> <span class="n">section</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Simple mean, no weight&quot;&quot;&quot;</span>
        <span class="c1"># Remove chezy where zero</span>
        <span class="n">link_chezy</span> <span class="o">=</span> <span class="n">link_chezy</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">link_chezy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">NaN</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">output</span><span class="o">.</span><span class="n">values</span>

    <span class="k">def</span> <span class="nf">_friction_weighing_area</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">link_chezy</span><span class="p">,</span> <span class="n">section</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute chezy by weighted average. Weights are determined based on area.</span>

<span class="sd">        Friction values are known at flow links, while areas are known at flow faces.</span>

<span class="sd">        The area of a flow link is defined as the average of the two faces it connects.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Remove chezy where zero</span>
        <span class="n">link_chezy</span> <span class="o">=</span> <span class="n">link_chezy</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span><span class="p">)</span>
        <span class="c1"># efs are the two faces the edge connects to</span>
        <span class="n">efs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fm_data</span><span class="p">[</span><span class="s2">&quot;edge_faces&quot;</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">_fm_data</span><span class="p">[</span><span class="s2">&quot;edge_section&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">section</span><span class="p">]</span>
        <span class="n">link_area</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ef</span> <span class="ow">in</span> <span class="n">efs</span><span class="p">:</span>
            <span class="c1"># compute the mean area for the two connecting faces</span>
            <span class="n">link_area</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fm_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;area_full&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">ef</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span>

        <span class="c1"># the weight of one link is defined as the sum of the linked areas</span>
        <span class="n">link_weight</span> <span class="o">=</span> <span class="n">link_area</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">link_area</span><span class="p">)</span>

        <span class="n">output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">link_chezy</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">link_weight</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">output</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">output</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">output</span>

    <span class="k">def</span> <span class="nf">_compute_section_widths</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes sections widths by dividing the area assigned to a section</span>
<span class="sd">        by the length of the cross-section.</span>

<span class="sd">        If the sum of the section widths is smaller than the flow width, the</span>
<span class="sd">        width is increase proportionally</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">total_area</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fm_data</span><span class="p">[</span><span class="s2">&quot;area&quot;</span><span class="p">])</span>
        <span class="n">unassigned_area</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fm_data</span><span class="p">[</span><span class="s2">&quot;area&quot;</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">_fm_data</span><span class="p">[</span><span class="s2">&quot;section&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">999</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">unassigned_area</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_logger_message</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">unassigned_area</span><span class="si">}</span><span class="s2"> m2 was not assigned to any section in input files, and is added to the main section&quot;</span><span class="p">,</span>
                <span class="s2">&quot;warning&quot;</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">for</span> <span class="n">section</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">section</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">section_area</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fm_data</span><span class="p">[</span><span class="s2">&quot;area&quot;</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">_fm_data</span><span class="p">[</span><span class="s2">&quot;section&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">section</span><span class="p">])</span>
                    <span class="o">+</span> <span class="n">unassigned_area</span>
                <span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">section_area</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fm_data</span><span class="p">[</span><span class="s2">&quot;area&quot;</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">_fm_data</span><span class="p">[</span><span class="s2">&quot;section&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">section</span><span class="p">])</span>
                    <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span>
                <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">section_widths</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_section_map</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">section</span><span class="p">)]]</span> <span class="o">=</span> <span class="n">section_area</span>

        <span class="c1"># Finally, the sum of section width should be greater or equal to the flow width</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_section_widths_greater_than_flow_width</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_compute_floodplain_base</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the self.floodplain_base attribute. The floodplain</span>
<span class="sd">        will be set at least 0.5 meter below the crest of the</span>
<span class="sd">        embankment, and otherwise at the average hight of the floodplain</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tolerance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_inifile</span><span class="p">()</span><span class="o">.</span><span class="n">get_parameter</span><span class="p">(</span><span class="s2">&quot;sdfloodplainbase&quot;</span><span class="p">)</span>
        <span class="c1"># Mean bed level in section 2 (floodplain)</span>
        <span class="n">floodplain_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fm_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;section&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">floodplain_mask</span><span class="o">.</span><span class="n">sum</span><span class="p">():</span>
            <span class="n">mean_floodplain_elevation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_fm_data</span><span class="p">[</span><span class="s2">&quot;bedlevel&quot;</span><span class="p">][</span><span class="n">floodplain_mask</span><span class="p">]</span>
            <span class="p">)</span>

            <span class="c1"># Tolerance. Base level must at least be some below the crest to prevent</span>
            <span class="c1"># numerical issues</span>

            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crest_level</span> <span class="o">-</span> <span class="n">tolerance</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">mean_floodplain_elevation</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">floodplain_base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">crest_level</span> <span class="o">-</span> <span class="n">tolerance</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_logger_message</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Mean floodpl. elev. (</span><span class="si">{</span><span class="n">mean_floodplain_elevation</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> m)&quot;</span>
                    <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;higher than crest level (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">crest_level</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">) + &quot;</span>
                    <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;tolerance (</span><span class="si">{</span><span class="n">tolerance</span><span class="si">}</span><span class="s2"> m)&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;warning&quot;</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">floodplain_base</span> <span class="o">=</span> <span class="n">mean_floodplain_elevation</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_logger_message</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Floodplain base level set to </span><span class="si">{</span><span class="n">mean_floodplain_elevation</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> m&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;debug&quot;</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">floodplain_base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">crest_level</span> <span class="o">-</span> <span class="n">tolerance</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_logger_message</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;No Floodplain found, floodplain defaults to </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">crest_level</span> <span class="o">-</span> <span class="n">tolerance</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_calc_chezy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">manning</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">depth</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="mi">6</span><span class="p">))</span> <span class="o">/</span> <span class="n">manning</span>

<div class="viewcode-block" id="CrossSection._identify_lakes"><a class="viewcode-back" href="../../chapters/technical_manual/numerical_methods.html#fm2prof.CrossSection.CrossSection._identify_lakes">[docs]</a>    <span class="k">def</span> <span class="nf">_identify_lakes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">waterdepth</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This algorithms determines whether a :ref:`2D cell &lt;section_parsing_2d_data&gt;` should</span>
<span class="sd">        be marked as a :term:`Lake&lt;Lakes&gt;`.</span>

<span class="sd">        Cells are marked as lake if the following conditions are both met:</span>
<span class="sd">            - the waterdepth on timestep :ref:`LakeTimeSteps &lt;parameter_laketimesteps&gt;` is positive</span>
<span class="sd">            - the waterdepth on timestep :ref:`LakeTimeSteps &lt;parameter_laketimesteps&gt;` is at least 1 cm higher than the waterlevel on timestep 0.</span>

<span class="sd">        Next, the following steps are taken</span>

<span class="sd">        - It is determined at what timestep the waterlevel in the lake starts rising. From that point on the lake counts as regular geometry and counts toward the total volume. A cell is considered active if its waterlevel has risen by 1 mm.</span>
<span class="sd">        - A correction matrix is built that contains the &#39;lake water level&#39; for each lake cell. This matrix is subtracted from the waterdepth to compute volumes.</span>


<span class="sd">        Args:</span>
<span class="sd">            waterdepth (pandas dataframe):</span>

<span class="sd">        Returns:</span>
<span class="sd">            lake_mask (ndarray): mask of all cells that are a &#39;lake&#39;</span>
<span class="sd">            wet_not_lake_mask (ndarray): mask of all cells that are wet, but not a lake</span>
<span class="sd">            lake_depth_correction (ndarray): the depth of a lake at the start of the 2D computation</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># preallocate arrays</span>
        <span class="n">plassen_depth_correction</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">waterdepth</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="c1"># check for non-rising waterlevels</span>
        <span class="n">waterdepth_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">waterdepth</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># find all wet cells</span>
        <span class="n">wet_mask</span> <span class="o">=</span> <span class="n">waterdepth</span> <span class="o">&gt;</span> <span class="mi">0</span>

        <span class="c1"># find all lakes</span>
        <span class="n">lake_mask</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">waterdepth</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_parameter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__cs_parameter_plassen_timesteps</span><span class="p">)]</span>
            <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span>
                <span class="n">waterdepth</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">get_parameter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__cs_parameter_plassen_timesteps</span><span class="p">)</span>
                <span class="p">]</span>
                <span class="o">-</span> <span class="n">waterdepth</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="o">&lt;=</span> <span class="mf">0.01</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">plassen_mask</span> <span class="o">=</span> <span class="n">lake_mask</span>

        <span class="c1"># Plassen_mask_time is to determine at whata timestep the lake starts rising again.</span>
        <span class="n">plassen_mask_time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">waterdepth</span><span class="o">.</span><span class="n">T</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">lake_mask</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

        <span class="c1"># At t=0, all lakes are inactive</span>
        <span class="n">plassen_mask_time</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lake_mask</span>

        <span class="c1"># walk through dataframe in time, for each timestep check</span>
        <span class="c1"># when to unmask a plassen cell</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">diff</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">waterdepth_diff</span><span class="o">.</span><span class="n">T</span><span class="p">):</span>
            <span class="n">final_mask</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">,</span> <span class="p">[(</span><span class="n">diff</span> <span class="o">&lt;=</span> <span class="mf">0.001</span><span class="p">),</span> <span class="p">(</span><span class="n">plassen_mask_time</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="kc">True</span><span class="p">)]</span>
            <span class="p">)</span>
            <span class="n">plassen_mask_time</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">final_mask</span>

        <span class="n">plassen_mask_time</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">plassen_mask_time</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># The depth of a lake is the waterdepth at t=0</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">depths</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">waterdepth</span><span class="p">):</span>
            <span class="n">plassen_depth_correction</span><span class="p">[</span><span class="n">lake_mask</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">waterdepth</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">lake_mask</span><span class="p">]</span>

        <span class="c1"># correct wet cells for plassen</span>
        <span class="n">wet_not_plas_mask</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">,</span> <span class="p">[(</span><span class="n">wet_mask</span> <span class="o">==</span> <span class="kc">True</span><span class="p">),</span> <span class="p">(</span><span class="n">plassen_mask_time</span> <span class="o">==</span> <span class="kc">False</span><span class="p">)]</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">lake_mask</span><span class="p">,</span> <span class="n">wet_not_plas_mask</span><span class="p">,</span> <span class="n">plassen_depth_correction</span></div>

<div class="viewcode-block" id="CrossSection._compute_css_above_z0"><a class="viewcode-back" href="../../chapters/technical_manual/numerical_methods.html#fm2prof.CrossSection.CrossSection._compute_css_above_z0">[docs]</a>    <span class="k">def</span> <span class="nf">_compute_css_above_z0</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">centre_level</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method computes for each level (z) above the water level at the first 2D output (z0),</span>
<span class="sd">        the corresponding :term:`Total width` and :term:`Flow width`. This is done in the following way:</span>

<span class="sd">        1. compute the total width by dividing the wet area by the cross-section length</span>
<span class="sd">        2. compute the flow width by dividing the flow area by the cross-section length</span>
<span class="sd">        3. Correct the flow width such that flow width is always increasing.</span>

<span class="sd">        Args:</span>
<span class="sd">            centre_level: the water level at the cross-section location (x, y), which is typically at the centre of the control volume</span>

<span class="sd">        Return:</span>

<span class="sd">            None: this method writes to the cross-section attributes _css_z, _css_total_width and _css_flow_width</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Set the level</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_css_z</span> <span class="o">=</span> <span class="n">centre_level</span>

        <span class="c1"># Set nan&#39;s to the minimum. NaN values occur lower z values at the start of computation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_css_z</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_css_z</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_css_z</span><span class="p">)</span>

        <span class="c1"># Compute widths</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_css_total_width</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fm_wet_area</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_css_flow_width</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fm_flow_area</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span>

        <span class="c1"># Flow width must increase at each z</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_css_flow_width</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_css_flow_width</span><span class="p">[</span><span class="o">-</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span>
                <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_css_flow_width</span><span class="p">[</span><span class="o">-</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_css_flow_width</span><span class="p">[</span><span class="o">-</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span>
            <span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_distinguish_flow_from_storage_2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">waterdepth</span><span class="p">,</span> <span class="n">velocity</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method determines which cells should be considered &#39;flowing&#39;. A cell is considered flowing if all following conditions are met:</span>

<span class="sd">        - the waterdepth greater than 0</span>
<span class="sd">        - the velocity is greater than :ref:`AbsoluteVelocityThreshold&lt;parameter_absolutevelocitythreshold&gt;`</span>
<span class="sd">        - the velocity is greater than the product of the mean velocity (of all cells within the control volume) and the :ref:`RelativeVelocityThreshold&lt;parameter_relativevelocitythreshold&gt;`</span>

<span class="sd">        Args:</span>
<span class="sd">            waterdepth (pandas Dataframe) with cell id</span>
<span class="sd">                for index and time in columns</span>
<span class="sd">            velocity (pandas Dataframe() with cell id</span>
<span class="sd">                for index and time in columns</span>

<span class="sd">        Returns:</span>
<span class="sd">            flow_mask (pandas Dataframe) with cell id for index and time in columns. True for flow, False for storage</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">flow_mask</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">waterdepth</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="o">&amp;</span> <span class="p">(</span><span class="n">velocity</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_parameter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__cs_parameter_velocity_threshold</span><span class="p">))</span>
            <span class="o">&amp;</span> <span class="p">(</span>
                <span class="n">velocity</span>
                <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_parameter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__cs_parameter_relative_threshold</span><span class="p">)</span>
                <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">velocity</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># shallow flows should not be used for identifying storage</span>
        <span class="c1"># (cells with small velocities are uncorrectly seen as storage)</span>
        <span class="n">waterdepth_correction</span> <span class="o">=</span> <span class="p">(</span><span class="n">waterdepth</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span>
            <span class="n">waterdepth</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_parameter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__cs_parameter_min_depth_storage</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># combine flow and depth mask to avoid assigning shallow flows</span>
        <span class="n">flow_mask</span> <span class="o">=</span> <span class="n">flow_mask</span> <span class="o">|</span> <span class="n">waterdepth_correction</span>

        <span class="k">return</span> <span class="n">flow_mask</span>

<div class="viewcode-block" id="CrossSection._distinguish_flow_from_storage"><a class="viewcode-back" href="../../chapters/technical_manual/numerical_methods.html#fm2prof.CrossSection.CrossSection._distinguish_flow_from_storage">[docs]</a>    <span class="k">def</span> <span class="nf">_distinguish_flow_from_storage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">waterdepth</span><span class="p">,</span> <span class="n">velocity</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method determines which cells should be considered &#39;flowing&#39;. A cell is considered flowing if all following conditions are met:</span>

<span class="sd">        - the waterdepth greater than 0</span>
<span class="sd">        - the velocity is greater than :ref:`AbsoluteVelocityThreshold&lt;parameter_absolutevelocitythreshold&gt;`</span>
<span class="sd">        - the velocity is greater than the product of the mean velocity (of all cells within the control volume) and the :ref:`RelativeVelocityThreshold&lt;parameter_relativevelocitythreshold&gt;`</span>

<span class="sd">        Args:</span>
<span class="sd">            waterdepth (pandas Dataframe) with cell id</span>
<span class="sd">                for index and time in columns</span>
<span class="sd">            velocity (pandas Dataframe() with cell id</span>
<span class="sd">                for index and time in columns</span>

<span class="sd">        Returns:</span>
<span class="sd">            flow_mask (pandas Dataframe) with cell id for index and time in columns. True for flow, False for storage</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">flow_mask</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">waterdepth</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="o">&amp;</span> <span class="p">(</span><span class="n">velocity</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_parameter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__cs_parameter_velocity_threshold</span><span class="p">))</span>
            <span class="o">&amp;</span> <span class="p">(</span>
                <span class="n">velocity</span>
                <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_parameter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__cs_parameter_relative_threshold</span><span class="p">)</span>
                <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">velocity</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># shallow flows should not be used for identifying storage</span>
        <span class="c1"># (cells with small velocities are uncorrectly seen as storage)</span>
        <span class="n">waterdepth_correction</span> <span class="o">=</span> <span class="p">(</span><span class="n">waterdepth</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span>
            <span class="n">waterdepth</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_parameter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__cs_parameter_min_depth_storage</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># combine flow and depth mask to avoid assigning shallow flows</span>
        <span class="c1"># flow_mask = flow_mask | waterdepth_correction</span>

        <span class="k">return</span> <span class="n">flow_mask</span></div>

<div class="viewcode-block" id="CrossSection._extend_css_below_z0"><a class="viewcode-back" href="../../chapters/technical_manual/numerical_methods.html#fm2prof.CrossSection.CrossSection._extend_css_below_z0">[docs]</a>    <span class="k">def</span> <span class="nf">_extend_css_below_z0</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">centre_level</span><span class="p">,</span>
        <span class="n">centre_depth</span><span class="p">,</span>
        <span class="n">waterlevel</span><span class="p">,</span>
        <span class="n">bedlevel_matrix</span><span class="p">,</span>
        <span class="n">area_matrix</span><span class="p">,</span>
        <span class="n">wet_not_plas_mask</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This methods computeS for level (z) below the water level at the first 2D output (z0) the corresponding</span>
<span class="sd">        :term:`Total width` and :term:`Flow width`. This is done in the following way:</span>

<span class="sd">        1. Take a number of steps (see note below) from z at t0 do the bed level at the :term:`Cross-section location`</span>
<span class="sd">        2. for each step, determine which cells should be counted</span>
<span class="sd">            - the bed level of the cell should be higher than the water level plus the tolerance (see note below)</span>
<span class="sd">            - the cell should not be part of a :term:`Lakes`</span>
<span class="sd">        3. Since there is no information on flow velocities, we cannot determine which cells are flowing and width are storage.</span>
<span class="sd">           Therefore is is decided like this</span>
<span class="sd">            - If :ref:`ExtrapolateStorage &lt;parameter_extrapolatestorage&gt;` is True, the flow area is the minimum of the flow area at t0 (from :ref:`wl_dependent_css`)</span>
<span class="sd">            - if :ref:`ExtrapolateStorage &lt;parameter_extrapolatestorage&gt;` is False, the flow area is equal to the total area</span>

<span class="sd">        .. note::</span>
<span class="sd">            - the number of steps between z at t0 to bed level is hard-coded at 10.</span>
<span class="sd">            - the tolerance for deciding which cell is wet is hardcoded at -1e-3</span>


<span class="sd">        Returns:</span>
<span class="sd">            None: This method extends the following attributes:</span>
<span class="sd">                    _css_z</span>
<span class="sd">                    _css_total_width</span>
<span class="sd">                    _css_flow_width</span>
<span class="sd">                    _fm_wet_area</span>
<span class="sd">                    _fm_flow_area</span>
<span class="sd">                    _fm_flow_volume</span>
<span class="sd">                    _fm_total_volume</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">bedlevel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fm_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;bedlevel&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">cell_area</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fm_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;area&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">flow_area_at_z0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fm_flow_area</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">lowest_level_of_css</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">centre_level</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">centre_depth</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="p">)</span>  <span class="c1"># this is in fact the bed level at centre point</span>
        <span class="n">centre_level_at_t0</span> <span class="o">=</span> <span class="n">centre_level</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">waterlevel_at_t0</span> <span class="o">=</span> <span class="n">waterlevel</span><span class="o">.</span><span class="n">values</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">waterdepth_at_t0</span> <span class="o">=</span> <span class="n">waterlevel_at_t0</span> <span class="o">-</span> <span class="n">bedlevel</span>
        <span class="n">waterdepth_at_t0</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">waterdepth_at_t0</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">tolerance</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1e-3</span>  <span class="c1"># at last point, this is still considered wet.</span>

        <span class="c1"># Take steps from z0 downward to the lowest level</span>
        <span class="k">for</span> <span class="n">dz</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">centre_level_at_t0</span> <span class="o">-</span> <span class="n">lowest_level_of_css</span><span class="p">,</span> <span class="mi">10</span><span class="p">):</span>
            <span class="n">centre_level_at_dz</span> <span class="o">=</span> <span class="n">centre_level_at_t0</span> <span class="o">-</span> <span class="n">dz</span>
            <span class="n">total_wet_area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span>
                <span class="n">cell_area</span><span class="p">[((</span><span class="n">waterdepth_at_t0</span> <span class="o">-</span> <span class="n">dz</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">tolerance</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">wet_not_plas_mask</span><span class="p">]</span>
            <span class="p">)</span>

            <span class="c1"># Extension of flow/storage below z0</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_parameter</span><span class="p">(</span><span class="s2">&quot;extrapolatestorage&quot;</span><span class="p">):</span>
                <span class="n">total_flow_area</span> <span class="o">=</span> <span class="n">total_wet_area</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_parameter</span><span class="p">(</span><span class="s2">&quot;extrapolatestorage&quot;</span><span class="p">):</span>
                <span class="n">total_flow_area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">total_wet_area</span><span class="p">,</span> <span class="n">flow_area_at_z0</span><span class="p">])</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_css_z</span> <span class="o">=</span> <span class="n">CrossSection</span><span class="o">.</span><span class="n">__append_to_start</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_css_z</span><span class="p">,</span> <span class="n">centre_level_at_dz</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_css_total_width</span> <span class="o">=</span> <span class="n">CrossSection</span><span class="o">.</span><span class="n">__append_to_start</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_css_total_width</span><span class="p">,</span> <span class="n">total_wet_area</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_css_flow_width</span> <span class="o">=</span> <span class="n">CrossSection</span><span class="o">.</span><span class="n">__append_to_start</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_css_flow_width</span><span class="p">,</span> <span class="n">total_flow_area</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fm_wet_area</span> <span class="o">=</span> <span class="n">CrossSection</span><span class="o">.</span><span class="n">__append_to_start</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_fm_wet_area</span><span class="p">,</span> <span class="n">total_wet_area</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fm_flow_area</span> <span class="o">=</span> <span class="n">CrossSection</span><span class="o">.</span><span class="n">__append_to_start</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_fm_flow_area</span><span class="p">,</span> <span class="n">total_flow_area</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fm_flow_volume</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fm_flow_volume</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fm_total_volume</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fm_total_volume</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">__get_extra_total_area</span><span class="p">(</span>
        <span class="n">waterlevel</span><span class="p">,</span> <span class="n">crest_level</span><span class="p">,</span> <span class="n">transition_height</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">hysteresis</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        releases extra area dependent on waterlevel using a logistic (sigmoid) function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="mf">0.00001</span>  <span class="c1"># accuracy parameter</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span>
            <span class="mi">1</span>
            <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">e</span>
            <span class="o">**</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span>
                <span class="o">/</span> <span class="p">(</span><span class="n">transition_height</span><span class="p">)</span>
                <span class="o">*</span> <span class="p">(</span><span class="n">waterlevel</span> <span class="o">-</span> <span class="p">(</span><span class="n">crest_level</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">transition_height</span><span class="p">))</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">__append_to_start</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">to_add</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        adds ``to add`` to beginning of array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">to_add</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__extend_css_with_constant_waterdepth</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">centre_level</span><span class="p">,</span> <span class="n">centre_depth</span><span class="p">,</span> <span class="n">bedlevel_matrix</span><span class="p">,</span> <span class="n">area_matrix</span><span class="p">,</span> <span class="n">plassen_mask</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extends the cross-sectional information below the water level</span>
<span class="sd">        at the first timestep,</span>
<span class="sd">        under assumption that the polygon formed by the water level</span>
<span class="sd">        and the bed level is convex.</span>
<span class="sd">        It works by walking down to the bed level at the center point</span>
<span class="sd">        in &#39;virtual water level steps&#39;.</span>
<span class="sd">        At each step, we sum the area of cells width bedlevels which</span>
<span class="sd">        would be submerged at that virtual water level.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">filter_by_depth_percentage</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_parameter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__cs_parameter_bedlevelcriterium</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span>
        <span class="p">)</span>
        <span class="n">filter_value</span> <span class="o">=</span> <span class="n">FE</span><span class="o">.</span><span class="n">empirical_ppf</span><span class="p">(</span>
            <span class="p">[</span><span class="n">filter_by_depth_percentage</span><span class="p">],</span> <span class="n">bedlevel_matrix</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_logger_message</span><span class="p">(</span>
            <span class="s2">&quot;Lowest </span><span class="si">{}% o</span><span class="s2">f bed levels are filtered (z&lt;</span><span class="si">{:.4f}</span><span class="s2">m)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">filter_by_depth_percentage</span><span class="p">,</span> <span class="n">filter_value</span>
            <span class="p">),</span>
            <span class="n">level</span><span class="o">=</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">level_z0</span> <span class="o">=</span> <span class="n">centre_level</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">bdata</span> <span class="o">=</span> <span class="n">bedlevel_matrix</span><span class="p">[</span><span class="o">~</span><span class="n">plassen_mask</span><span class="p">]</span>
        <span class="n">bmask</span> <span class="o">=</span> <span class="p">(</span><span class="n">bdata</span> <span class="o">&lt;</span> <span class="n">level_z0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">bdata</span> <span class="o">&gt;=</span> <span class="n">filter_value</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_logger_message</span><span class="p">(</span>
            <span class="s2">&quot;Number of points below z0 after applying filter: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">bmask</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="p">),</span>
            <span class="n">level</span><span class="o">=</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Compute values at z0</span>
        <span class="n">bedlevels_below_z0</span> <span class="o">=</span> <span class="n">bdata</span><span class="p">[</span><span class="n">bmask</span><span class="p">]</span>
        <span class="n">lowest_level_below_z0</span> <span class="o">=</span> <span class="n">centre_level</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">centre_depth</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">flow_area_at_z0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fm_flow_area</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">total_area_at_z0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fm_wet_area</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">unique_level_below_z0</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">lowest_level_below_z0</span><span class="p">,</span> <span class="n">level_z0</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
        <span class="p">):</span>

            <span class="c1"># count area</span>
            <span class="n">areas</span> <span class="o">=</span> <span class="n">area_matrix</span><span class="p">[</span><span class="n">bedlevels_below_z0</span> <span class="o">&lt;=</span> <span class="n">unique_level_below_z0</span><span class="p">]</span>

            <span class="c1"># Set area, such that the width computed from this area is equal or lower</span>
            <span class="c1"># than the minimum width from the flow-dependent level</span>
            <span class="n">area_at_unique_level</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span>
                <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">areas</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">total_area_at_z0</span><span class="p">]</span>
            <span class="p">)</span>

            <span class="c1"># Extension of flow/storage below z0</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_parameter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__cs_parameter_storagemethod_wli</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">flow_area_at_unique_level</span> <span class="o">=</span> <span class="n">area_at_unique_level</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_parameter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__cs_parameter_storagemethod_wli</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">flow_area_at_unique_level</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">area_at_unique_level</span><span class="p">,</span> <span class="n">flow_area_at_z0</span><span class="p">]</span>
                <span class="p">)</span>

            <span class="c1"># Insert values in existing arrays</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_css_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_css_z</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">unique_level_below_z0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_css_flow_width</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_css_flow_width</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">flow_area_at_unique_level</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_css_total_width</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_css_total_width</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">area_at_unique_level</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fm_wet_area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fm_wet_area</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">area_at_unique_level</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fm_flow_area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_fm_flow_area</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">flow_area_at_unique_level</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fm_flow_volume</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fm_flow_volume</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fm_total_volume</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fm_total_volume</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">__return_volume_error</span><span class="p">(</span><span class="n">predicted</span><span class="p">,</span> <span class="n">measured</span><span class="p">,</span> <span class="n">gof</span><span class="o">=</span><span class="s2">&quot;rmse&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the squared relative error</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">non_nan_mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">predicted</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">measured</span><span class="p">)</span>
        <span class="n">predicted</span> <span class="o">=</span> <span class="n">predicted</span><span class="p">[</span><span class="n">non_nan_mask</span><span class="p">]</span>
        <span class="n">measured</span> <span class="o">=</span> <span class="n">measured</span><span class="p">[</span><span class="n">non_nan_mask</span><span class="p">]</span>
        <span class="n">error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">predicted</span> <span class="o">-</span> <span class="n">measured</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">measured</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">measured</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">error</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_check_monotonicity</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        for given input array, create mask such that when applied to the array,</span>
<span class="sd">        all values are monotonically rising</span>

<span class="sd">        method 1: remove values were z is falling from array</span>
<span class="sd">        method 2: sort array such that z is always rising (default)</span>

<span class="sd">        Arguments:</span>
<span class="sd">            arr: 1d numpy array</span>

<span class="sd">        return:</span>
<span class="sd">            mask such that arr[mask] is monotonically rising</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="kc">True</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)):</span>
                <span class="c1"># Last index that had rising value</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">mask</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">mask</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_check_total_width_greater_than_flow_width</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If total width is smaller than flow width, set flow width to total width</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_css_flow_width</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_css_total_width</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_css_flow_width</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_css_total_width</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_logger_message</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Reduces flow widths at </span><span class="si">{</span><span class="nb">sum</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span><span class="si">}</span><span class="s2"> points to be same as total&quot;</span><span class="p">,</span> <span class="s2">&quot;debug&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_check_section_widths_greater_than_flow_width</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">total_section_width</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">width</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_widths</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">total_section_width</span> <span class="o">+=</span> <span class="n">width</span>

        <span class="n">dif</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flow_width</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">total_section_width</span>
        <span class="k">if</span> <span class="n">dif</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">section_widths</span><span class="p">[</span><span class="s2">&quot;main&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dif</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_logger_message</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Increased main section width by </span><span class="si">{</span><span class="n">dif</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;warning&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_parameter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_inifile</span><span class="p">()</span><span class="o">.</span><span class="n">get_parameter</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
</code></pre></div>


  <hr>
<div class="md-source-file">
  <small>
    
      Last update:
      Apr 23, 2022
    
  </small>
</div>

              
            </article>
          </div>
        </div>
        
          <a href="#" class="md-top md-icon" data-md-component="top" data-md-state="hidden">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"/></svg>
            Back to top
          </a>
        
      </main>
      
        <footer class="md-footer">
  
  
  
  <div class="md-footer-meta md-typeset">
    
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-footer-copyright__highlight">
        &#169; Copyright 2022 Deltares.
        
    </div>
  
    Created using
    <a href="https://www.sphinx-doc.org/" target="_blank" rel="noopener">Sphinx</a>
    4.5.0.
     and
    <a href="https://github.com/jbms/sphinx-immaterial/" target="_blank" rel="noopener">Sphinx-Immaterial</a>
  
</div>
      
    </div>
    
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    <script id="__config" type="application/json">{"base": "../..", "features": ["navigation.expand", "navigation.sections", "navigation.top"], "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version.title": "Select version"}, "version": {"provider": "mike", "staticVersions": [{"aliases": [], "title": "ReadTheDocs", "version": "https://sphinx-immaterial.rtfd.io"}, {"aliases": [], "title": "Github Pages", "version": "https://jbms.github.io/sphinx-immaterial"}], "versionPath": null}}</script>
    
    
      <script src="../../_static/javascripts/bundle.cf32e622.min.js"></script>
        <script src="../../_static/sphinxcontrib-images/LightBox2/lightbox2/dist/js/lightbox-plus-jquery.min.js"></script>
        <script src="../../_static/sphinxcontrib-images/LightBox2/lightbox2-customize/jquery-noconflict.js"></script>
    
  </body>
</html>