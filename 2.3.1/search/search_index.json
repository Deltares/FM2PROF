{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"CHANGELOG/","title":"Changelog","text":""},{"location":"CHANGELOG/#v228-2023-10-03","title":"v2.2.8 (2023-10-03)","text":"<p>This version update FM2PROF to Python 3.10 or higher. It removes unused dependencies and updates the package system <code>poetry</code> to version 1.8.2. Due to this switch, the commitizen workflow is currently not used, and the documentation system switch from sphinx to mkdocs. </p> <p>This is the first version to be published to PyPi, which means that FM2PROF can now be installed using pip</p> <p><code>pip install fm2prof</code></p> <p>Known issues:</p> <ul> <li>The executable is not available for this version. </li> </ul>"},{"location":"CHANGELOG/#v227-2023-10-03","title":"v2.2.7 (2023-10-03)","text":"<p>This version adds the parameter stoptime to utils.Compare1D2D and makes both starttime and stoptime parameters optional. With these parameters users can crop the section of the results over which statistics will be computed and figures made.</p>"},{"location":"CHANGELOG/#v226-2023-10-01","title":"v2.2.6 (2023-10-01)","text":"<ul> <li>Fixed an issue where irregular station names like <code>MA_67.00Z</code> caused a sorting error in <code>utils.Compare1D2D</code></li> </ul>"},{"location":"CHANGELOG/#v225-2023-07-28","title":"v2.2.5 (2023-07-28)","text":"<ul> <li>FM2PROF now validates the \"SkipMaps\" parameter and throws error if its value is larger than the available number of maps</li> <li>Fixed bug that threw exception if roughness tables could not be produced during finalization step</li> <li>Fixed bug that prevented BranchRules file to be read if multiple empty lines existed at the end of the file</li> <li>Fixed bug where <code>utils.Compare1D2D</code> would throw exception if input netCDF files did not exist, but csv files did. </li> <li>Fixed bug in <code>utils.Compare1D2D</code> where execution failed if a QH relationship could not be produced</li> <li>Statistics are no longer computed on initialization of <code>utils.Compare1D2D</code>. Instead, they are not computed when requested during evaluation. </li> </ul>"},{"location":"CHANGELOG/#v224-2023-07-05","title":"v2.2.4 (2023-07-05)","text":"<ul> <li>Implemented 'onlyFirst' and 'onlyLast' rules for BranchRules file</li> </ul>"},{"location":"CHANGELOG/#v223-2022-12-21","title":"v2.2.3 (2022-12-21)","text":"<ul> <li>Implemented functionality to compare two 1D models for bed level change, Summer dike change and width change</li> </ul>"},{"location":"CHANGELOG/#v222-2022-08-26","title":"v2.2.2 (2022-08-26)","text":""},{"location":"CHANGELOG/#fix","title":"Fix","text":"<ul> <li>wrong method output type</li> <li>catching wrong exception</li> <li>exception in utils</li> </ul>"},{"location":"CHANGELOG/#v221-2022-08-24","title":"v2.2.1 (2022-08-24)","text":""},{"location":"CHANGELOG/#v220-2022-07-13","title":"v2.2.0 (2022-07-13)","text":""},{"location":"CHANGELOG/#fix_1","title":"Fix","text":"<ul> <li>log style now the same as stream, added support for tqdm</li> <li>added cross-section progress to log</li> <li>(#34)</li> <li>revised logger style (#34)</li> <li>first figure does not use correct style</li> <li>added 10 cm tolerance to section width correction</li> <li>main section width check</li> <li>output path compare1d2d discharge figure</li> <li> </li> </ul>"},{"location":"CHANGELOG/#33","title":"33","text":""},{"location":"CHANGELOG/#v212-2022-07-05","title":"v2.1.2 (2022-07-05)","text":""},{"location":"CHANGELOG/#v211-2022-07-04","title":"v2.1.1 (2022-07-04)","text":""},{"location":"CHANGELOG/#fix_2","title":"Fix","text":"<ul> <li>missing index.rst</li> </ul>"},{"location":"CHANGELOG/#v210-2022-07-04","title":"v2.1.0 (2022-07-04)","text":""},{"location":"CHANGELOG/#fix_3","title":"Fix","text":"<ul> <li>macos/linux posixpath fail fix</li> <li>isolated set_locale and wrapped in try/except</li> <li>possibly fix posix path error with trailing whitespace</li> <li>run with ini suffix fix (#29)</li> <li>docs now only build on master</li> </ul>"},{"location":"CHANGELOG/#feat","title":"Feat","text":"<ul> <li>expanded cli</li> <li>groundwork for expansion of cli (#31, #30)</li> <li>overwrite option for output, single output folder (#31)</li> <li>added new tools to utils</li> </ul>"},{"location":"CHANGELOG/#v200-2022-06-28","title":"v2.0.0 (2022-06-28)","text":""},{"location":"CHANGELOG/#fix_4","title":"Fix","text":"<ul> <li>IniFile: fixed bug introduced by switching to pathlib</li> <li>output path now relative to config file</li> </ul>"},{"location":"CHANGELOG/#v153-2022-05-27","title":"v1.5.3 (2022-05-27)","text":""},{"location":"CHANGELOG/#fix_5","title":"Fix","text":"<ul> <li>adding cm accuracy to section width check (#23)</li> </ul>"},{"location":"CHANGELOG/#v152-2022-05-27","title":"v1.5.2 (2022-05-27)","text":""},{"location":"CHANGELOG/#fix_6","title":"Fix","text":"<ul> <li>adding cm accuracy to section width check (#23)</li> <li>main section width check</li> <li>fixed bug introduced by earlier fix :p</li> <li>files now relative to config file (#24)</li> </ul>"},{"location":"CHANGELOG/#v151-2022-05-26","title":"v1.5.1 (2022-05-26)","text":""},{"location":"CHANGELOG/#fix_7","title":"Fix","text":"<ul> <li>CrossSection.py: add main section width requirement (#23)</li> </ul>"},{"location":"CHANGELOG/#v150-2022-05-26","title":"v1.5.0 (2022-05-26)","text":""},{"location":"CHANGELOG/#fix_8","title":"Fix","text":"<ul> <li>CrossSection.py: add main section width requirement (#23)</li> <li>sc bug</li> </ul>"},{"location":"CHANGELOG/#feat_1","title":"Feat","text":"<ul> <li>cli: new cli with poetry script hook &amp; python -m</li> </ul>"},{"location":"CHANGELOG/#v144-2022-05-03","title":"v1.4.4 (2022-05-03)","text":""},{"location":"CHANGELOG/#fix_9","title":"Fix","text":"<ul> <li>update black to 22.3 (#16)</li> </ul>"},{"location":"CHANGELOG/#v143-2021-11-29","title":"v1.4.3 (2021-11-29)","text":""},{"location":"blog/","title":"Blog","text":""},{"location":"markdown/conceptual_design/","title":"Methodology","text":"<p>This chapter describes in more detail the steps FM2PROF takes to go from a 2D representation of reality to a 1D representation of reality. Conceptually, FM2PROF works in three distinct steps: (1) initialisation, (2) building cross-sections and (3) finalisation.</p>"},{"location":"markdown/conceptual_design/#initialisation","title":"Initialisation","text":"Image caption <p>The initialisation step involves parsing (i.e. reading and making available for further analysis) the 2D data. In this step control volumes and sections are defined as well. This step may take some time to complete, but this preprocessing greatly reduces the computation times in the next step.</p>"},{"location":"markdown/conceptual_design/#import-region-file","title":"Import region file","text":"<p>The <code>Region</code> file is specified in the configuration file.</p> <p>Warning</p> <p>For any reasonably sized river model, it is currently not advised to supply a polygon. Instead, a NetCDF file should be supplied. See <code>issue_region_polygon</code> for more information.</p>"},{"location":"markdown/conceptual_design/#import-section-file","title":"Import section file","text":"<p>The <code>Section</code> file is specified in the configuration file.</p> <p>Warning</p> <p>For any reasonably sized river model, it is currently not advised to supply a polygon. Instead, a NetCDF file should be supplied. See <code>issue_region_polygon</code> for more information.</p>"},{"location":"markdown/conceptual_design/#import-2d-data","title":"Import 2D data","text":""},{"location":"markdown/conceptual_design/#section_parsing_2d_data","title":"Parsing 2D data","text":"<p>Dflow2d uses a staggered grid to solve the (hydrostatic) flow equations. Because of this staggered approach, there is not a single 2D point that has all information. Flow information (flow velocity, discharge) is stored in [flow links]{.title-ref}, while geometry (bed level) is stored in cell faces. needs both information from the faces, as from the links.</p> The dflow2d staggered grid. <p>Below is a table that lists all variables read by from dflowd map output.</p> <p>FM2PROF variable                    Variable in dflow2d output</p> <p>x (at face)                         mesh2d_face_x</p> <p>y (at face)                         mesh2d_face_y</p> <p>area (at face)                      mesh2d_flowelem_ba</p> <p>bedlevel (at face)                  mesh2d_flowelem_bl</p> <p>x (at flow link)                    mesh2d_edge_x</p> <p>y (at flow link)                    mesh2d_edge_y</p> <p>edge_faces (at flow link)           mesh2d_edge_faces</p> <p>edge_nodes (at flow link)           mesh2d_edge_nodes</p> <p>waterdepth                          mesh2d_waterdepth</p> <p>waterlevel                          mesh2d_s1</p> <p>chezy_mean                          mesh2d_czs</p> <p>chezy_edge                          mesh2d_czu</p> <p>velocity_x                          mesh2d_ucx</p> <p>velocity_y                          mesh2d_ucy</p> <p>velocity_edge                       mesh2d_u1</p> <p>: Overview of variables from the 2D model that are used by FM2PROF</p>"},{"location":"markdown/conceptual_design/#classification-of-volumes","title":"Classification of volumes","text":"<p><code>Control volumes</code> are used to define which 2D datepoints are linked to which 1D cross-section. This is done in the following steps:</p> <ul> <li>Each node, link and face is assigned a <code>Region</code>{.interpreted-text     role=\"term\"}. This is currently done through DeltaShell (see     <code>issue_region_polygon</code>)</li> <li>For each region seperately, a scikit-learn     KNearestNeighbour     classifier is trained.</li> <li>The classifier is used to uniquely identify each 2D link and each     face to a 1D cross-section</li> </ul>"},{"location":"markdown/conceptual_design/#classification-of-sections","title":"Classification of sections","text":"<p><code>Sections &lt;Section&gt;</code> are used to output a different roughness function for the main channel and the floodplains. The purpose of the classification is to determine whether a 2D point belongs to the main channel section, or to the floodplain section (see warning below).</p> <p>Two methods are implemented:</p> <ul> <li><code>Variance based classification&lt;section_classification_variance&gt;</code>{.interpreted-text     role=\"ref\"}</li> <li>Polygon-based classification using DeltaShell (see     <code>issue_region_polygon</code>)</li> </ul> <p>Warning</p> <p>If classification is done using DeltaShell, it is possible to define more than two sections. However, this functionality is not tested and may not work properly.</p>"},{"location":"markdown/conceptual_design/#build-cross-section","title":"Build Cross-Section","text":"The dflow2d staggered grid. <p>Once initialisation is complete, will loop over each <code>cross-section location&lt;Cross-section location&gt;</code>{.interpreted-text role=\"term\"}. In each iteration, the program takes two steps: (1) building the geometry and (2) building the roughness tables.</p> <p>Warning</p> <p>No cross-section will be generated for locations that have no 2D data assigned or have less than 10 faces assigned. This may happen if a location lies outside the 2D grid, or if there are many cross-section closely together. If this happens, an error is raised by FM2PROF. The user should check the cross-section location input file to resolve the problem.</p>"},{"location":"markdown/conceptual_design/#build-geometry","title":"Build Geometry","text":"<p>In each loop, a number of steps is taken based on the 2D data that is uniquely assigned to that cross-section:</p> <ul> <li><code>Lakes</code> are identified using the     <code>identify_lakes</code></li> <li><code>Flow volume</code> and     <code>Storage volume</code> are seperated using     the <code>distinguish_storage</code></li> <li>The     <code>water level dependent geometry&lt;Water level (in)dependent geometry&gt;</code>{.interpreted-text     role=\"term\"} is computed using <code>wl_dependent_css</code>{.interpreted-text     role=\"ref\"}</li> <li>The     <code>water level independent geometry&lt;Water level (in)dependent geometry&gt;</code>{.interpreted-text     role=\"term\"} is computed using     <code>wl_independent_css</code></li> <li>The parameters for <code>Summerdikes</code> are     defined using the <code>sd_optimisation</code></li> <li>Finally, the cross-section is simplified using the     Visvalingam-Whyatt method of poly-line vertex reduction     <code>simplify_css</code></li> </ul>"},{"location":"markdown/conceptual_design/#build-roughness","title":"Build roughness","text":"<p>At each cross-section point, a roughness look-up table is constructed that relates water level (in m + NAP) to a Ch\u00e9zy roughness coefficient. This is done in three steps:</p> <ul> <li>For each section, a roughness table is constructed by averaging the     2D points</li> </ul>"},{"location":"markdown/conceptual_design/#finalisation","title":"Finalisation","text":"The dflow2d staggered grid."},{"location":"markdown/configuration/","title":"FM2PROF configuration","text":""},{"location":"markdown/configuration/#exec-1--input","title":"input","text":""},{"location":"markdown/configuration/#exec-1--2dmapoutput","title":"2DMapOutput","text":"<p>type: str</p> <p>default value: None</p> <p>Output file from FM2D model (.net file)</p>"},{"location":"markdown/configuration/#exec-1--crosssectionlocationfile","title":"CrossSectionLocationFile","text":"<p>type: str</p> <p>default value: None</p> <p>.csv or .txt file (, as delimiter) that contains four columns: X_coordinate,Y_coordinate,BranchName,Length,Chainage.</p>"},{"location":"markdown/configuration/#exec-1--regionpolygonfile","title":"RegionPolygonFile","text":"<p>type: str</p> <p>default value: None</p> <p>User defined polygons in json format</p>"},{"location":"markdown/configuration/#exec-1--sectionpolygonfile","title":"SectionPolygonFile","text":"<p>type: str</p> <p>default value: None</p> <p>User defined polygons in json format</p>"},{"location":"markdown/configuration/#exec-1--parameters","title":"parameters","text":""},{"location":"markdown/configuration/#exec-1--casename","title":"CaseName","text":"<p>type: str</p> <p>default value: None</p> <p>Subdirectory name under OutputDir (no space); if not specified, 'CaseXX' (01, 02..) are used</p>"},{"location":"markdown/configuration/#exec-1--maximumpointsinprofile","title":"MaximumPointsInProfile","text":"<p>type: int</p> <p>default value: None</p> <p>Number of points which are used to generate cross-sections</p>"},{"location":"markdown/configuration/#exec-1--conveyancedetectionmethod","title":"ConveyanceDetectionMethod","text":"<p>type: int</p> <p>default value: None</p> <p>[0] method based on mean flow velocity, [1] method based on maximum flow velocity (default)</p>"},{"location":"markdown/configuration/#exec-1--absolutevelocitythreshold","title":"AbsoluteVelocityThreshold","text":"<p>type: float</p> <p>default value: None</p> <p>Absolute velocity threshold in m/s. Used to determine storage</p>"},{"location":"markdown/configuration/#exec-1--relativevelocitythreshold","title":"RelativeVelocityThreshold","text":"<p>type: float</p> <p>default value: None</p> <p>Relative velocity threshold (percentage). Used to determine storage</p>"},{"location":"markdown/configuration/#exec-1--minimumdepththreshold","title":"MinimumDepthThreshold","text":"<p>type: float</p> <p>default value: None</p> <p>Minimum depth (m) for storage identification</p>"},{"location":"markdown/configuration/#exec-1--bedlevelcriterium","title":"BedlevelCriterium","text":"<p>type: float</p> <p>default value: None</p> <p>Ignore the lowest percentage of bed level points</p>"},{"location":"markdown/configuration/#exec-1--laketimesteps","title":"LakeTimesteps","text":"<p>type: int</p> <p>default value: None</p> <p>Number of timesteps that are used for identifying lakes</p>"},{"location":"markdown/configuration/#exec-1--extrapolatestorage","title":"ExtrapolateStorage","text":"<p>type: fm2prof.IniFile.ImportBoolType</p> <p>default value: None</p> <p>Add storage to water level independent cross-section section</p>"},{"location":"markdown/configuration/#exec-1--sdcorrection","title":"SDCorrection","text":"<p>type: fm2prof.IniFile.ImportBoolType</p> <p>default value: None</p> <p>Use summerdike volume correction</p>"},{"location":"markdown/configuration/#exec-1--sdfloodplainbase","title":"SDFloodplainBase","text":"<p>type: float</p> <p>default value: None</p> <p>minimum distance between floodplain base level and crest level in meters</p>"},{"location":"markdown/configuration/#exec-1--sdtransitionheight","title":"SDTransitionHeight","text":"<p>type: float</p> <p>default value: None</p> <p>Transition height at the summer dike (m)</p>"},{"location":"markdown/configuration/#exec-1--sdoptimisationmethod","title":"SDOptimisationMethod","text":"<p>type: int</p> <p>default value: None</p> <p>[0] Optimise on Total volume, [1] optimise  on flow volume, [2] optimise on both</p>"},{"location":"markdown/configuration/#exec-1--frictionweighingmethod","title":"FrictionWeighingMethod","text":"<p>type: int</p> <p>default value: None</p> <p>Options. [0] arithmetric mean, [1] Weighted average</p>"},{"location":"markdown/configuration/#exec-1--skipmaps","title":"SkipMaps","text":"<p>type: int</p> <p>default value: None</p> <p>number of timesteps to skip at begin of 2D output. Use to skip problems related to initial conditions. </p>"},{"location":"markdown/configuration/#exec-1--classificationmethod","title":"ClassificationMethod","text":"<p>type: int</p> <p>default value: None</p> <p>How to classify 2D output using Section and Region polygons. Options: [0] Do not classify regions or sections. [1] Use DeltaShell</p>"},{"location":"markdown/configuration/#exec-1--minimumtotalwidth","title":"MinimumTotalWidth","text":"<p>type: float</p> <p>default value: None</p> <p>Minimum width in meters. Zero width may lead to numerical instability in 1D solvers</p>"},{"location":"markdown/configuration/#exec-1--debug","title":"debug","text":""},{"location":"markdown/configuration/#exec-1--exportcssdata","title":"ExportCSSData","text":"<p>type: fm2prof.IniFile.ImportBoolType</p> <p>default value: None</p> <p>If True, exports pickled (1) input data for cross-section object, (2) flow mask for conveyance/storage.</p>"},{"location":"markdown/configuration/#exec-1--exportmapfiles","title":"ExportMapFiles","text":"<p>type: fm2prof.IniFile.ImportBoolType</p> <p>default value: None</p> <p>Export detailed map output. Only use for small models or limited number of cross-sections b/c output can be huge.</p>"},{"location":"markdown/configuration/#exec-1--cssselection","title":"CssSelection","text":"<p>type: fm2prof.IniFile.ImportListType</p> <p>default value: None</p> <p>provide comma separated list of ints; e.g. 38, 39, 40. Leave empty to generate all cross-sections</p>"},{"location":"markdown/configuration/#exec-1--output","title":"output","text":""},{"location":"markdown/configuration/#exec-1--outputdirectory","title":"OutputDirectory","text":"<p>type: str</p> <p>default value: None</p> <p>Output files are saved in OutputDir/CaseName; if not specified, subdirectory is created in the current directory</p>"},{"location":"markdown/contributing/","title":"Contributing","text":""},{"location":"markdown/contributing/#set-up-development-environment","title":"Set up development environment","text":""},{"location":"markdown/contributing/#style-conventions","title":"Style conventions","text":"<p>Please use Google-style docstring syntax</p>"},{"location":"markdown/contributing/#test-new-code","title":"Test new code","text":"<p>To run tests locally, use pytest:</p> <p><code>poetry run pytest --cov=fm2prof</code></p> <p>To check coverage:</p> <p><code>poetry run pytest --cov=fm2prof</code></p>"},{"location":"markdown/contributing/#deploying","title":"Deploying","text":""},{"location":"markdown/contributing/#locally-build-executable","title":"Locally build executable","text":"<p>To build a local version of an FM2PROF executable, run:</p> <p><code>poetry run pyinstaller FM2PROF_WINDOWS.spec</code></p>"},{"location":"markdown/contributing/#making-a-new-release","title":"Making a new release","text":"<p>After merging a PR, make a new tag. Using version <code>v2.3.0</code> as an example;</p> <p><code>git tag v2.3.0</code></p> <p>Use Github interface to draft a new release. Attach the executable. Then, update the documentation:</p> <p><code>poetry run mike deploy v2.3.0 latest -u</code></p> <p>Checkout the documentation branch</p> <p><code>git checkout gh-pages</code></p> <p>and push changes to github</p> <p><code>git push</code></p>"},{"location":"markdown/glossary/","title":"Glossary","text":""},{"location":"markdown/glossary/#region","title":"Region","text":"<p>Regions are used to have some finer control over which 2D model output is assigned to which 1D cross-section. If no region are defined, 2D model output is assigned to cross-section using k-nearest neighbour. This is not always a good approach, for example if a tributary or retention area. In the figure a section of the River Meuse is plotted near the Blitterswijck retention area. The retention area is demarcated from the main river by levees. Cross-sections generated for the retention area should therefore not 'eat out of' the area of the main channel - which could results in a small cross-section non-physical constriction of the flow.</p> Region polygons are used to prevent cross-sections generated     in the retention area to 'eat out of' the main channel. Within each     region polygon (red borders) nearest neighour is used to assign 2D     points to cross-sections. Points with the same color are associated with     the same 1D cross-section"},{"location":"markdown/glossary/#section","title":"Section","text":"<p>Section are used to divide the cross-section between floodplain and main channel (e.g. the 'floodplain' section and the 'main channel' section). This distinction is only used to assign different roughness values to each section.</p>"},{"location":"markdown/glossary/#water-level-independent-geometry","title":"Water level (in)dependent geometry","text":"<p>It is often not possible to start the 2D computation from a completely dry bed - instead some initial water level is present in the model. This initial condition divides the 1D geometry in water level dependent part and a water level independent part. Below the initial condition, we cannot take advantage of the 2D model to tell us which cells are part of the conveyance and which cells are wet. Instead, the water level is artificially lowered in a number of steps to estimate the volume below the initial water levels.</p>"},{"location":"markdown/glossary/#summerdikes","title":"Summerdikes","text":"<p>Summerdikes are a Dutch term for levees that are designed to be flooded with higher discharges, but not with relatively low floods (i.e.: they withstand summer floods). They contrast with 'winterdikes', which are designed to not flood at all. Summerdikes effectively comparimentalise the floodplain. They can have a profound effect on stage-discharge relationships: as these levees overflow the compartments start flowing which leads to a retention effect. Such an effect cannot be modelled using regulare cross-sections. SOBEK therefore has a 'summerdike' functionality.</p>"},{"location":"markdown/glossary/#control-volume","title":"Control volume","text":"<p>A control volume of a cross-section is the geographical part of the 2D model that is associated with that cross-section. Contol volumes are assigned by k-Nearest Neighbour classification.</p> <p>Note</p> <p>Control volumes are the equivalent of WAQ2PROF's sobekvakken</p> A control volume"},{"location":"markdown/glossary/#lakes","title":"Lakes","text":"<p>Lakes are water bodies that are not hydraulically connected to the main channel in the first few timesteps of the 2D model computation. They do not contribute to the volume present in the control volume until they connect with the rest of the river and will not feature in the water level independent computation.  Water bodies that are connected to the main channel in the first few timesteps do count as volume. However, as these likely do not contribute to conveyance, they will be flagged as 'storage' instead.</p>"},{"location":"markdown/glossary/#cross-section-location","title":"Cross-section location","text":"<p>The cross-section location is defined in the <code>CrossSectionLocationFile</code>.</p>"},{"location":"markdown/glossary/#total-volume","title":"Total volume","text":"<p>The Total volume refers to the volume of water [in m\\^3] within a <code>Control volume</code> for a given water level at the <code>Cross-section location</code>{.interpreted-text role=\"term\"}. The total volume is the sum of the <code>Flow volume</code> and the <code>Storage volume</code>.</p>"},{"location":"markdown/glossary/#flow-volume","title":"Flow volume","text":"<p>The Flow volume is defined as the volume of water [in m\\^3] for which the conditions for flowing water are met. This volume is considered to be available for the conveyance of water through the <code>Control volume</code>.</p> <p>See <code>distinguish_storage</code></p>"},{"location":"markdown/glossary/#storage-volume","title":"Storage volume","text":"<p>The Storage volume is defined as the volume of water [in m\\^3] for which the conditions for flowing water are not met. Storage volume does not contribute to conveyance, but serves only for water retention. Examples include groyne fields and</p> <p>See <code>distinguish_storage</code></p>"},{"location":"markdown/glossary/#total-width","title":"Total width","text":"<p>See <code>Total volume</code></p>"},{"location":"markdown/glossary/#flow-width","title":"Flow width","text":"<p>See <code>Flow volume</code></p>"},{"location":"markdown/installation/","title":"Getting started","text":""},{"location":"markdown/installation/#installation","title":"Installation","text":"<p>FM2PROF is a package written in Python. If you're familiar with Python, you can install FM2PROF with <code>pip</code>, the Python package manager. If not, we recommend the executable. </p>"},{"location":"markdown/installation/#with-pip","title":"With pip","text":"<p>FM2PROF is published as a Python package and can be installed with <code>pip</code>, ideally by using a virtual environment and using Python 3.10 or higher. Open up a terminal and install FM2PROF with:</p> LatestSpecific versionupdate existing install <pre><code>pip install fm2prof\n</code></pre> <pre><code>pip install fm2prof=\"2.2.8\"\n</code></pre> <pre><code>pip install fm2prof --upgrade\n</code></pre> <p>This will also install compatible versions of all dependencies like <code>numpy</code>, and <code>pandas</code>. </p>"},{"location":"markdown/installation/#executable","title":"Executable","text":"<p>FM2PROF is compiled to an executable for Windows (version 1.5.4 and higher). Download them from Releases on the Github home page.</p> <p>The executable provides a command line interface (CLI). To use it, make sure it is available in your Path. To view available options, open a Terminal and type:</p> <pre><code>FM2PROF --help\n</code></pre> <p>Warning</p> <p>The first time you call the executable, it may take a long time to produce results. This is because your OS needs to unpack the executable.</p>"},{"location":"markdown/numerical_methods/","title":"Numerical methods","text":""},{"location":"markdown/numerical_methods/#cross-section-construction","title":"Cross-section construction","text":""},{"location":"markdown/numerical_methods/#conveyance-storage-separation","title":"Conveyance-storage separation","text":"<p>In 1D hydrodynamic models, flow through a cross-section is resolved assuming a  cross-sectionally average velocity. This assumed that the entire cross-section is available to for conveyance. However in reality some parts of the cross-section do not contribute to flow. For example, sections of a river behind a levee where water is stagnant contribute to storage (volume), but not flow. </p> <p>SOBEK enables distinction between 'flow area' and 'storage area'. <code>fm2prof</code> implements methods to resolve from 2D model output which cells add to the 'flow volume' within a control volume and which to the storage volume. </p> <p><code>fm2prof</code> implements two methods. The configuration parameter <code>ConveyanceDetectionMethod</code> is used to determine which method is used.</p> <p><code>max_method</code> A cell is considered flowing if the velocity magnitude is more than the average of the three higher flow velocities per outputmap multiplied by the  <code>relative velocity threshold</code> OR if the flow velocity meets the absolute threshold <code>absolute velocity threshold</code></p> <p><code>mean_method</code> Not recommended. Legacy method.</p> <p>Parameters:</p> Name Type Description Default <code>waterdepth</code> <code>DataFrame</code> <p>dataframe of a control volume with waterdepths per cel per output map</p> required <code>velocity</code> <code>DataFrame</code> <p>dataframe of a control volume with velocity magnitude per cel per output map</p> required <p>Returns:</p> Name Type Description <code>flow_mask</code> <code>DataFrame</code> <p>dataframe of a control volume with the flow condition per cel per output map. <code>True</code> means flowing, <code>False</code> storage.</p> Source code in <code>fm2prof\\CrossSection.py</code> <pre><code>def _distinguish_conveyance_from_storage(self, waterdepth: pd.DataFrame, velocity: pd.DataFrame) -&gt; pd.DataFrame:\n    \"\"\"\n    In 1D hydrodynamic models, flow through a cross-section is resolved assuming a \n    cross-sectionally average velocity. This assumed that the entire cross-section\n    is available to for conveyance. However in reality some parts of the cross-section\n    do not contribute to flow. For example, sections of a river behind a levee where\n    water is stagnant contribute to storage (volume), but not flow. \n\n    SOBEK enables distinction between 'flow area' and 'storage area'. `fm2prof` implements\n    methods to resolve from 2D model output which cells add to the 'flow volume' within a\n    [control volume](glossary.md#control-volume) and which to the storage volume. \n\n    `fm2prof` implements two methods. The configuration parameter [`ConveyanceDetectionMethod`](configuration.md#exec-1--conveyancedetectionmethod) is used\n    to determine which method is used.\n\n    **`max_method`**\n    A cell is considered flowing if the velocity magnitude is more than the average\n    of the three higher flow velocities per outputmap multiplied by the \n    [`relative velocity threshold`](configuration.md#exec-1--relativevelocitythreshold) OR\n    if the flow velocity meets the absolute threshold [`absolute velocity threshold`](configuration.md#exec-1--absolutevelocitythreshold)\n\n    **`mean_method`**\n    Not recommended. Legacy method.\n\n    Parameters:\n        waterdepth: dataframe of a control volume with waterdepths per cel per output map\n        velocity:  dataframe of a control volume with velocity magnitude per cel per output map\n\n    Returns:\n        flow_mask: dataframe of a control volume with the flow condition per cel per output map. `True` means flowing, `False` storage. \n    \"\"\"\n    @staticmethod\n    def max_velocity_method(waterdepth: pd.DataFrame, velocity: pd.DataFrame) -&gt; pd.DataFrame:\n        \"\"\"\n        This method was added in version 2.3 because the mean_velocity_method\n        led to unreasonably high conveyance if the river was connected to \n        an inland harbour. \n        \"\"\"\n        # This condition may be redundant\n        waterdepth_condition = waterdepth &gt; 0\n\n        # Determine maximum as the average of the top 3 flow velocities\n        maxv = velocity.max()\n        for i in velocity:\n            maxv[i] = velocity[i].sort_values().iloc[-3:].mean()\n\n        # Relative to max condition\n        relative_velocity_condition = velocity &gt; maxv*self.get_parameter(self.__cs_parameter_relative_threshold)\n\n        # Absolute flow condition\n        absolute_velocity_condition =  velocity &gt; self.get_parameter(self.__cs_parameter_velocity_threshold)\n\n        # Flow mask determines which cells are conveyance (TRUE)\n        flow_mask = waterdepth_condition &amp; (relative_velocity_condition | absolute_velocity_condition)\n\n        return flow_mask\n\n    @staticmethod\n    def mean_velocity_method(waterdepth, velocity):\n        \"\"\"\n        This was the default method &lt; 2.3. This method leads to unreasonably \n        high conveyance if the river was connected to an inland harbour. \n        \"\"\"\n        # apply rolling average over the velocities\n        # to smooth out extreme values\n        velocity = velocity.rolling(\n            window=10, min_periods=1, center=True).mean()\n\n        flow_mask = (\n            (waterdepth &gt; 0)\n            &amp; (velocity &gt; self.get_parameter(self.__cs_parameter_velocity_threshold))\n            &amp; (\n                velocity\n                &gt; self.get_parameter(self.__cs_parameter_relative_threshold)\n                * np.mean(velocity)\n            )\n        )\n\n        return flow_mask\n\n    match self.get_inifile().get_parameter(self.__cs_parameter_conveyance_detection_method):\n        case 0:\n            return mean_velocity_method(waterdepth, velocity)    \n        case 1:\n            return max_velocity_method(waterdepth, velocity)\n        case _:\n            self.set_logger_message('Invalid conveyance method. Defaulting to [1]', 'warning')\n            return max_velocity_method(waterdepth, velocity)\n</code></pre>"},{"location":"markdown/numerical_methods/#simplification","title":"Simplification","text":"<p>The cross-section geometry generated by <code>fm2prof</code> contains one point per output timestep in the 2D map file. This resolution is often too high given the complexity of the cross-sections, and results in very large input files for the 1D model. Therefore <code>fm2prof</code> includes a simplification algorithm that reduces the number of points while preservering the shape of the geometry. This algorithm reduces as many points until the number specified in <code>MaximumPointsInProfile</code> is reached.</p> <p>We use the Visvalingam-Whyatt method of poly-line vertex reduction<sup>1</sup>. The total width is leading for the simplification of the geometry meaning that the choice for which points to remove to simplify the geometry is based on the total width. Subsequently, the corresponding point are removed from the flow width.</p> <ol> <li> <p>Visvalingam, M and Whyatt J D (1993) \"Line Generalisation by Repeated Elimination of Points\", Cartographic J., 30 (1), 46 - 51 URL: http://web.archive.org/web/20100428020453/http://www2.dcs.hull.ac.uk/CISRG/publications/DPs/DP10/DP10.html     Implemented vertex reduction methods:\u00a0\u21a9</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>count_after</code> <code>int</code> <p>number of points in cross-section after application of this function</p> <code>20</code> Source code in <code>fm2prof\\CrossSection.py</code> <pre><code>def reduce_points(self, count_after: int = 20) -&gt; None:\n    \"\"\"\n    The cross-section geometry generated by `fm2prof` contains one point per output\n    timestep in the 2D map file. This resolution is often too high given the\n    complexity of the cross-sections, and results in very large input files for the\n    1D model. Therefore `fm2prof` includes a simplification algorithm that reduces\n    the number of points while preservering the shape of the geometry. This algorithm\n    reduces as many points until the number specified in\n    `MaximumPointsInProfile` is reached.\n\n    We use the Visvalingam-Whyatt method of poly-line vertex reduction[^1].\n    The [total width](glossary.md#total-width) is leading for the simplification of the geometry meaning\n    that the choice for which points to remove to simplify the geometry is based on\n    the total width. Subsequently, the corresponding point are removed from the [flow width](glossary.md#flow-width).\n\n    [^1]:\n        Visvalingam, M and Whyatt J D (1993) \"Line Generalisation by Repeated Elimination of Points\", Cartographic J., 30 (1), 46 - 51 URL: http://web.archive.org/web/20100428020453/http://www2.dcs.hull.ac.uk/CISRG/publications/DPs/DP10/DP10.html\n            Implemented vertex reduction methods:\n\n\n    Parameters:\n        count_after: number of points in cross-section after application of this function\n\n    \"\"\"\n\n    n_before_reduction = self.get_number_of_vertices()\n\n    points = np.array(\n        [\n            [self._css_z[i], self._css_total_width[i]]\n            for i in range(n_before_reduction)\n        ]\n    )\n\n    # The number of points is equal to n, it cannot be further reduced\n    reduced_index = np.array([True] * n_before_reduction)\n\n    if n_before_reduction &gt; count_after:\n        try:\n            simplifier = PS.VWSimplifier(points)\n            reduced_index = simplifier.from_number_index(count_after)\n        except Exception as e:\n            self.set_logger_message(\n                \"Exception thrown while using polysimplify: \"\n                + \"{}\".format(str(e)),\n                \"error\",\n            )\n\n    # Write to attributes\n    self.z = self._css_z[reduced_index]\n    self.total_width = self._css_total_width[reduced_index]\n    self.flow_width = self._css_flow_width[reduced_index]\n\n    self.set_logger_message(\n        \"Cross-section reduced \"\n        + \"from {} \".format(n_before_reduction)\n        + \"to {} points\".format(len(self.total_width))\n    )\n\n    self._css_is_reduced = True\n</code></pre>"},{"location":"markdown/numerical_methods/#lake-identification","title":"Lake identification","text":"<p>This algorithms determines whether a 2D cell should be marked as Lake.</p> <p>Cells are marked as lake if the following conditions are both met: - the waterdepth on timestep LakeTimeSteps is positive - the waterdepth on timestep LakeTimeSteps is at least 1 cm higher than the waterlevel on timestep 0.</p> <p>Next, the following steps are taken</p> <ul> <li>It is determined at what timestep the waterlevel in the lake starts rising. From that point on the lake counts as regular geometry and counts toward the total volume. A cell is considered active if its waterlevel has risen by 1 mm.</li> <li>A correction matrix is built that contains the 'lake water level' for each lake cell. This matrix is subtracted from the waterdepth to compute volumes.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>waterdepth</code> <code>DataFrame</code> <p>a DataFrame containing all waterdepth output in the control volume</p> required <p>Returns:</p> Name Type Description <code>lake_mask</code> <code>ndarray</code> <p>mask of all cells that are a 'lake'</p> <code>wet_not_lake_mask</code> <code>ndarray</code> <p>mask of all cells that are wet, but not a lake</p> <code>lake_depth_correction</code> <code>ndarray</code> <p>the depth of a lake at the start of the 2D computation</p> Source code in <code>fm2prof\\CrossSection.py</code> <pre><code>def _identify_lakes(self, waterdepth:pd.DataFrame) -&gt; np.ndarray:\n    \"\"\"\n    This algorithms determines whether a 2D cell should\n    be marked as [Lake](glossary.md#Lakes).\n\n    Cells are marked as lake if the following conditions are both met:\n    - the waterdepth on timestep [LakeTimeSteps](configuration.md#exec-1--laketimesteps) is positive\n    - the waterdepth on timestep [LakeTimeSteps](configuration.md#exec-1--laketimesteps) is at least 1 cm higher than the waterlevel on timestep 0.\n\n    Next, the following steps are taken\n\n    - It is determined at what timestep the waterlevel in the lake starts rising. From that point on the lake counts as regular geometry and counts toward the total volume. A cell is considered active if its waterlevel has risen by 1 mm.\n    - A correction matrix is built that contains the 'lake water level' for each lake cell. This matrix is subtracted from the waterdepth to compute volumes.\n\n\n    Parameters:\n        waterdepth: a DataFrame containing all waterdepth output in the [control volume](glossary.md#control-volume)\n\n    Returns:\n        lake_mask: mask of all cells that are a 'lake'\n        wet_not_lake_mask: mask of all cells that are wet, but not a lake\n        lake_depth_correction: the depth of a lake at the start of the 2D computation\n\n    \"\"\"\n    # preallocate arrays\n    plassen_depth_correction = np.zeros(waterdepth.shape, dtype=float)\n\n    # check for non-rising waterlevels\n    waterdepth_diff = np.diff(waterdepth, n=1, axis=-1)\n\n    # find all wet cells\n    wet_mask = waterdepth &gt; 0\n\n    # find all lakes\n    lake_mask = (\n        waterdepth.T.iloc[self.get_parameter(self.__cs_parameter_plassen_timesteps)]\n        &gt; 0\n    ) &amp; (\n        np.abs(\n            waterdepth.T.iloc[\n                self.get_parameter(self.__cs_parameter_plassen_timesteps)\n            ]\n            - waterdepth.T.iloc[0]\n        )\n        &lt;= 0.01\n    )\n\n    self.plassen_mask = lake_mask\n\n    # Plassen_mask_time is to determine at whata timestep the lake starts rising again.\n    plassen_mask_time = np.zeros((len(waterdepth.T), len(lake_mask)), dtype=bool)\n\n    # At t=0, all lakes are inactive\n    plassen_mask_time[0, :] = lake_mask\n\n    # walk through dataframe in time, for each timestep check\n    # when to unmask a plassen cell\n    for i, diff in enumerate(waterdepth_diff.T):\n        final_mask = reduce(\n            np.logical_and, [(diff &lt;= 0.001), (plassen_mask_time[i] == True)]\n        )\n        plassen_mask_time[i + 1, :] = final_mask\n\n    plassen_mask_time = pd.DataFrame(plassen_mask_time).T\n\n    # The depth of a lake is the waterdepth at t=0\n    for i, depths in enumerate(waterdepth):\n        plassen_depth_correction[lake_mask, i] = -waterdepth.T.iloc[0][lake_mask]\n\n    # correct wet cells for plassen\n    wet_not_plas_mask = reduce(\n        np.logical_and, [(wet_mask == True), np.asarray(plassen_mask_time == False)]\n    )\n\n    return lake_mask, wet_not_plas_mask, plassen_depth_correction\n</code></pre>"},{"location":"markdown/quickstart/","title":"Tutorial","text":"<p>In this tutorial we will walk through the basics of creating a 1D model input from a 2D model.</p> <p>To use , we need at least two input files:</p> <ul> <li><code>2DMapOutput</code></li> <li><code>CrossSectionLocationFile</code></li> </ul> <p>in this tutorial we will use the test data bundled with the package. You will find this in the source directory:</p> <pre><code># 2DMapOutput\ntests\\test_data\\cases\\case_02_compound\\Data\\2DModelOutput\\FlowFM_map.nc \n# CrossSectionLocationFile\ntests\\test_data\\cases\\case_02_compound\\Data\\cross_section_locations.xyz  \n</code></pre> <p>This case is a simple 2D compound channel model.</p>"},{"location":"markdown/quickstart/#create-a-new-project","title":"Create a new project","text":"<p>To start a new project:</p> PythonCLI <pre><code>from fm2prof.IniFile import IniFile\n\ninifile = IniFile().print_configuration()\nini_path = f\"MyProject.ini\"\n\nwith open(ini_path, \"w\") as f:\n    f.write(inifile)\n</code></pre> <pre><code>FM2PROF create MyProject\n</code></pre> <p>This will create a valid configuration file with all parameters set to their default values. </p>"},{"location":"markdown/quickstart/#modify-the-input","title":"Modify the input","text":"<p>For the purpose of this tutorial, move the 2D model simulation file to [input]{.title-ref}. This is not a requirement - you can refer to any location on your pc.</p> <p>Open the configuration file with your favorite text editor and change the following two settings to your input data:</p> <pre><code>[input]\n2DMapOutput                   =         # Output file from FM2D model (.net file)\nCrossSectionLocationFile      =           # .csv or .txt file (, as delimiter) that contains four columns: X_coordinate,Y_coordinate,BranchName,Length,Chainage.\n</code></pre> <p>To be sure you used the correct data, run:</p> PythonCLI <pre><code>from fm2prof import Project\n\nproject = Project(\"MyProject.ini\")\n</code></pre> <pre><code>FM2PROF check MyProject\n</code></pre> <p>Study the output. Errors indicate that something is wrong with your input. In that case, you will need to correct the configurationfile.</p>"},{"location":"markdown/quickstart/#run-fm2prof","title":"Run FM2PROF","text":"<p>You should also see a print-out of the configuration file. These are the settings that will be used and can be altered using a config file. The configuration file does not need all parameters to be specified. If a parameter is not in the configuration file, default values will be used.</p> <p>The following examples run FM2PROF, overwrite any existing results and produce figures of the generated cross-sections. </p> PythonCLI <pre><code>from fm2prof import Project\nfrom fm2prof.utils import VisualiseOutput\n\n# load project\nproject = Project(\"MyProject.ini\")\n\n# overwrite = True overwrites any existing output\nproject.run(overwrite=True)\n\n# to visualize cross-sectino putput:\nvis = VisualiseOutput(\n            project.get_output_directory(), \n            logger=project.get_logger()\n        )\n\nfor css in vis.cross_sections:\n    vis.figure_cross_section(css)\n</code></pre> <pre><code>FM2PROF run MyProject -o -p\n</code></pre> <p>All <code>outputFiles</code> are written to the <code>output</code> directory specified in the FM2PROF configuration file. </p> <p>After generating output it is important to check whether everything went well. See the following links to learn more about available tools:</p> <ul> <li>Inspection cross-sections using a notebook</li> </ul>"},{"location":"notebooks/cross_section_data/","title":"Inspecting cross-sections","text":"In\u00a0[1]: Copied! <pre>import pickle\n\n# Cross-sections test cases\ncases = [\"waal_1_40147.826\", \"reevediep_2888.800\", \"veessenwapenveld_3519.948\", \"ketelmeer02_0.000\", \"twentekanaal_941.714\", \"nederrijn_20011.855\"]\n\ncase = cases[5]\n\nwith open(fr\"../../tests/test_data/cross_sections/{case}.pickle\", \"rb\") as f:\n    data = pickle.load(f)\n</pre> import pickle  # Cross-sections test cases cases = [\"waal_1_40147.826\", \"reevediep_2888.800\", \"veessenwapenveld_3519.948\", \"ketelmeer02_0.000\", \"twentekanaal_941.714\", \"nederrijn_20011.855\"]  case = cases[5]  with open(fr\"../../tests/test_data/cross_sections/{case}.pickle\", \"rb\") as f:     data = pickle.load(f) In\u00a0[2]: Copied! <pre>import matplotlib.pyplot as plt\n\nvariable = 'bedlevel'  # other variables to plot: bedlevel, section, region, area\nx = data.get('fm_data').get('x')\ny = data.get('fm_data').get('y')\nz = data.get('fm_data').get(variable)\n\nfig, ax = plt.subplots(1)\nsc = ax.scatter(x/1000, y/1000, c=z)\nax.set_aspect('equal', adjustable='box')\nax.set_title(case)\ncb = plt.colorbar(sc)\ncb.set_label(variable)\n</pre> import matplotlib.pyplot as plt  variable = 'bedlevel'  # other variables to plot: bedlevel, section, region, area x = data.get('fm_data').get('x') y = data.get('fm_data').get('y') z = data.get('fm_data').get(variable)  fig, ax = plt.subplots(1) sc = ax.scatter(x/1000, y/1000, c=z) ax.set_aspect('equal', adjustable='box') ax.set_title(case) cb = plt.colorbar(sc) cb.set_label(variable)  In\u00a0[6]: Copied! <pre>%matplotlib widget\nfrom ipywidgets import *\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import ListedColormap\n\nvariable = 'velocity' # try also: waterlevel, waterdepth\n\nz = data.get('fm_data').get(variable)\nfig, ax = plt.subplots(1)\n\nsc = ax.scatter(x/1000, y/1000, c=z.iloc[6])\nax.set_aspect('equal', adjustable='box')\nax.set_title(case)\ncb = plt.colorbar(sc)\ncb.set_label(variable)\nplt.show(fig)\n\ndef update(i):\n    plt.gca()\n    zi = z.iloc[i]\n    ax.scatter(x/1000, y/1000, c=zi)\n    fig.canvas.draw()\n\ninteract(update, i=widgets.IntSlider(min=0, max=46, step=1, value=6))\n</pre> %matplotlib widget from ipywidgets import * import numpy as np import matplotlib.pyplot as plt from matplotlib.colors import ListedColormap  variable = 'velocity' # try also: waterlevel, waterdepth  z = data.get('fm_data').get(variable) fig, ax = plt.subplots(1)  sc = ax.scatter(x/1000, y/1000, c=z.iloc[6]) ax.set_aspect('equal', adjustable='box') ax.set_title(case) cb = plt.colorbar(sc) cb.set_label(variable) plt.show(fig)  def update(i):     plt.gca()     zi = z.iloc[i]     ax.scatter(x/1000, y/1000, c=zi)     fig.canvas.draw()  interact(update, i=widgets.IntSlider(min=0, max=46, step=1, value=6))                      Figure                  <pre>interactive(children=(IntSlider(value=6, description='i', max=46), Output()), _dom_classes=('widget-interact',\u2026</pre> Out[6]: <pre>&lt;function __main__.update(i)&gt;</pre> In\u00a0[7]: Copied! <pre>with open(fr\"../../tests/test_data/cross_sections/{case}_flowmask.pickle\", \"rb\") as f:\n    flowmask = pickle.load(f)\n</pre> with open(fr\"../../tests/test_data/cross_sections/{case}_flowmask.pickle\", \"rb\") as f:     flowmask = pickle.load(f) <p>The code below visualises how this criterium is met during the 2D simulation. You'll see that as you progress in time, more cells will mee the criterium.</p> In\u00a0[8]: Copied! <pre>%matplotlib widget\nfrom ipywidgets import *\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import ListedColormap\n\nfig, ax = plt.subplots(1)\nfm = flowmask.T.iloc[0]\nsc = ax.scatter(x/1000, y/1000, c=fm)\nax.set_aspect('equal', adjustable='box')\nax.set_title(case)\ncb = plt.colorbar(sc)\ncb.set_label(\"meets conveyance criterium\")\nplt.show(fig)\n\ndef update(i):\n    plt.gca()\n    fm = flowmask.T.iloc[i]\n    ax.scatter(x/1000, y/1000, c=fm)\n    fig.canvas.draw()\n\ninteract(update, i=widgets.IntSlider(min=0, max=46, step=1, value=6))\n</pre> %matplotlib widget from ipywidgets import * import numpy as np import matplotlib.pyplot as plt from matplotlib.colors import ListedColormap  fig, ax = plt.subplots(1) fm = flowmask.T.iloc[0] sc = ax.scatter(x/1000, y/1000, c=fm) ax.set_aspect('equal', adjustable='box') ax.set_title(case) cb = plt.colorbar(sc) cb.set_label(\"meets conveyance criterium\") plt.show(fig)  def update(i):     plt.gca()     fm = flowmask.T.iloc[i]     ax.scatter(x/1000, y/1000, c=fm)     fig.canvas.draw()  interact(update, i=widgets.IntSlider(min=0, max=46, step=1, value=6))                      Figure                  <pre>interactive(children=(IntSlider(value=6, description='i', max=46), Output()), _dom_classes=('widget-interact',\u2026</pre> Out[8]: <pre>&lt;function __main__.update(i)&gt;</pre>"},{"location":"notebooks/cross_section_data/#inspecting-cross-sections","title":"Inspecting cross-sections\u00b6","text":"<p>If deeper analysis of cross-section is required, you can enable the option <code>ExportCSSData</code> in the fm2prof project configuration file. This notebooks shows some techniques to visualise this data.</p>"},{"location":"notebooks/cross_section_data/#loading-the-data","title":"Loading the data\u00b6","text":"<p>Example output is provided in the tests directory of the fm2prof repository. This is pickled data, so we'll use <code>pickle</code> to read it.</p>"},{"location":"notebooks/cross_section_data/#visualise-the-cross-section-input-data","title":"Visualise the cross-section input data\u00b6","text":"<p>When unpickled, this data is a <code>dict</code> of pandas DataFrames. The variable <code>data</code> holds all information that the <code>fm2prof.CrossSection</code> class uses to build a 1D cross-section. Let's visualise this data:</p>"},{"location":"notebooks/cross_section_data/#visualising-velocity","title":"Visualising velocity\u00b6","text":""},{"location":"notebooks/cross_section_data/#visualising-conveyance","title":"Visualising conveyance\u00b6","text":"<p>Another provided data file is the <code>flowmask.pickle</code> file. This file contains information generated during the cross-section production. The <code>flowmask</code> encodes information on which cells meet the conveyance criterium (stroomvoeringscriterium).</p>"}]}